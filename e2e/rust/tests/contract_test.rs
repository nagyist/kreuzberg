// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
// To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang rust

// Tests for contract fixtures.
#![allow(clippy::too_many_lines)]
use e2e_rust::{assertions, resolve_document};
use kreuzberg::KreuzbergError;
use kreuzberg::core::config::ExtractionConfig;

#[tokio::test]
async fn test_api_batch_bytes_async() {
    // Tests async batch bytes extraction API (batch_extract_bytes)

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping api_batch_bytes_async: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let file_bytes = std::fs::read(&document_path).expect("Failed to read document file");
    let mime_type = kreuzberg::detect_mime_type(&document_path, true).expect("Failed to detect MIME type");

    let result = match kreuzberg::batch_extract_bytes(vec![(file_bytes.clone(), mime_type.clone())], &config).await {
        Err(err) => panic!("Extraction failed for api_batch_bytes_async: {err:?}"),
        Ok(results) => results.into_iter().next().expect("Expected at least one result"),
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_contains_any(&result, &["May 5, 2023", "Mallori"]);
}

#[test]
fn test_api_batch_bytes_sync() {
    // Tests sync batch bytes extraction API (batch_extract_bytes_sync)

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping api_batch_bytes_sync: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let file_bytes = std::fs::read(&document_path).expect("Failed to read document file");
    let mime_type = kreuzberg::detect_mime_type(&document_path, true).expect("Failed to detect MIME type");

    let result = match kreuzberg::batch_extract_bytes_sync(vec![(file_bytes.clone(), mime_type.clone())], &config) {
        Err(err) => panic!("Extraction failed for api_batch_bytes_sync: {err:?}"),
        Ok(results) => results.into_iter().next().expect("Expected at least one result"),
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_contains_any(&result, &["May 5, 2023", "Mallori"]);
}

#[tokio::test]
async fn test_api_batch_file_async() {
    // Tests async batch file extraction API (batch_extract_file)

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping api_batch_file_async: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let result = match kreuzberg::batch_extract_file(vec![document_path.clone()], &config).await {
        Err(err) => panic!("Extraction failed for api_batch_file_async: {err:?}"),
        Ok(results) => results.into_iter().next().expect("Expected at least one result"),
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_contains_any(&result, &["May 5, 2023", "Mallori"]);
}

#[test]
fn test_api_batch_file_sync() {
    // Tests sync batch file extraction API (batch_extract_file_sync)

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping api_batch_file_sync: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let result = match kreuzberg::batch_extract_file_sync(vec![document_path.clone()], &config) {
        Err(err) => panic!("Extraction failed for api_batch_file_sync: {err:?}"),
        Ok(results) => results.into_iter().next().expect("Expected at least one result"),
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_contains_any(&result, &["May 5, 2023", "Mallori"]);
}

#[tokio::test]
async fn test_api_extract_bytes_async() {
    // Tests async bytes extraction API (extract_bytes)

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping api_extract_bytes_async: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let file_bytes = std::fs::read(&document_path).expect("Failed to read document file");
    let mime_type = kreuzberg::detect_mime_type(&document_path, true).expect("Failed to detect MIME type");

    let result = match kreuzberg::extract_bytes(&file_bytes, &mime_type, &config).await {
        Err(err) => panic!("Extraction failed for api_extract_bytes_async: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_contains_any(&result, &["May 5, 2023", "Mallori"]);
}

#[test]
fn test_api_extract_bytes_sync() {
    // Tests sync bytes extraction API (extract_bytes_sync)

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping api_extract_bytes_sync: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let file_bytes = std::fs::read(&document_path).expect("Failed to read document file");
    let mime_type = kreuzberg::detect_mime_type(&document_path, true).expect("Failed to detect MIME type");

    let result = match kreuzberg::extract_bytes_sync(&file_bytes, &mime_type, &config) {
        Err(err) => panic!("Extraction failed for api_extract_bytes_sync: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_contains_any(&result, &["May 5, 2023", "Mallori"]);
}

#[tokio::test]
async fn test_api_extract_file_async() {
    // Tests async file extraction API (extract_file)

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping api_extract_file_async: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let result = match kreuzberg::extract_file(&document_path, None, &config).await {
        Err(err) => panic!("Extraction failed for api_extract_file_async: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_contains_any(&result, &["May 5, 2023", "Mallori"]);
}

#[test]
fn test_api_extract_file_sync() {
    // Tests sync file extraction API (extract_file_sync)

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping api_extract_file_sync: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for api_extract_file_sync: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_contains_any(&result, &["May 5, 2023", "Mallori"]);
}

#[test]
fn test_config_chunking() {
    // Tests chunking configuration with chunk assertions

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_chunking: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "chunking": {
    "max_chars": 500,
    "max_overlap": 50
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for config_chunking: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_chunks(&result, Some(1), None, Some(true), None);
}

#[test]
fn test_config_chunking_markdown() {
    // Tests markdown-aware chunker type

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_chunking_markdown: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "chunking": {
    "chunker_type": "markdown",
    "max_chars": 500,
    "max_overlap": 50
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_chunking_markdown: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_chunking_markdown: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_chunking_markdown: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_chunks(&result, Some(1), None, Some(true), None);
}

#[test]
fn test_config_chunking_small() {
    // Tests chunking with very small chunk size produces more chunks

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_chunking_small: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "chunking": {
    "max_chars": 100,
    "max_overlap": 20
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_chunking_small: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_chunking_small: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_chunking_small: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_chunks(&result, Some(2), None, Some(true), None);
}

#[test]
fn test_config_djot_content() {
    // Tests djot output format converts content to djot markup

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_djot_content: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "output_format": "djot"
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_djot_content: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_djot_content: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_djot_content: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
}

#[test]
fn test_config_document_structure() {
    // Tests include_document_structure config produces document tree

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_document_structure: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "include_document_structure": true
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for config_document_structure: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_document(&result, true, Some(1), Some(&["paragraph"]), None);
}

#[test]
fn test_config_document_structure_disabled() {
    // Tests document field is null when include_document_structure is false

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_document_structure_disabled: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config = ExtractionConfig::default();

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for config_document_structure_disabled: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_document(&result, false, None, None, None);
}

#[test]
fn test_config_document_structure_headings() {
    // Tests document structure extraction with heading nodes on a DOCX

    let document_path = resolve_document("office/docx/headers.docx");
    if !document_path.exists() {
        println!(
            "Skipping config_document_structure_headings: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "include_document_structure": true
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!(
                "Skipping config_document_structure_headings: missing dependency {dep}",
                dep = dep
            );
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_document_structure_headings: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_document_structure_headings: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(
        &result,
        &["application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
    );
    assertions::assert_document(&result, true, Some(1), Some(&["heading", "paragraph"]), None);
}

#[test]
fn test_config_document_structure_with_headings() {
    // Tests document structure with DOCX heading-driven nesting

    let document_path = resolve_document("docx/fake.docx");
    if !document_path.exists() {
        println!(
            "Skipping config_document_structure_with_headings: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "include_document_structure": true
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for config_document_structure_with_headings: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(
        &result,
        &["application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
    );
    assertions::assert_document(&result, true, Some(1), None, None);
}

#[test]
fn test_config_element_types() {
    // Tests element-based result format with element type assertions on DOCX

    let document_path = resolve_document("office/docx/headers.docx");
    if !document_path.exists() {
        println!(
            "Skipping config_element_types: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "result_format": "element_based"
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_element_types: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_element_types: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_element_types: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(
        &result,
        &["application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
    );
    assertions::assert_elements(&result, Some(1), Some(&["title", "narrative_text"]));
}

#[test]
fn test_config_force_ocr() {
    // Tests force_ocr configuration option

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_force_ocr: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "force_ocr": true
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_force_ocr: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_force_ocr: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_force_ocr: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 5);
}

#[test]
fn test_config_html_options() {
    // Tests extraction with HTML conversion options configured

    let document_path = resolve_document("html/complex_table.html");
    if !document_path.exists() {
        println!(
            "Skipping config_html_options: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "html_options": {
    "include_links": true
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for config_html_options: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["text/html"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_not_empty(&result);
}

#[test]
fn test_config_images() {
    // Tests image extraction configuration with image assertions

    let document_path = resolve_document("pdf/embedded_images_tables.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_images: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "images": {
    "extract_images": true
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for config_images: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_images(&result, Some(1), None, None);
}

#[test]
fn test_config_keywords() {
    // Tests keyword extraction via YAKE algorithm

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_keywords: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "keywords": {
    "algorithm": "yake",
    "max_keywords": 10
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_keywords: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_keywords: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_keywords: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_keywords(&result, Some(true), Some(1), None);
}

#[test]
fn test_config_language_detection() {
    // Tests language detection configuration

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_language_detection: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "language_detection": {
    "enabled": true
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for config_language_detection: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_detected_languages(&result, &["eng"], Some(0.5));
}

#[test]
fn test_config_language_multi() {
    // Tests multi-language detection config

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_language_multi: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "language_detection": {
    "detect_multiple": true,
    "enabled": true
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_language_multi: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_language_multi: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_language_multi: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_detected_languages(&result, &["eng"], None);
}

#[test]
fn test_config_pages() {
    // Tests page extraction and page marker configuration

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!("Skipping config_pages: missing document at {}", document_path.display());
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "pages": {
    "extract_pages": true,
    "insert_page_markers": true
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_pages: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_pages: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_pages: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_contains_any(&result, &["PAGE"]);
}

#[test]
fn test_config_pages_extract() {
    // Tests page extraction config producing per-page content array

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_pages_extract: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "pages": {
    "extract_pages": true
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_pages_extract: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_pages_extract: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_pages_extract: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_pages(&result, Some(1), None);
}

#[test]
fn test_config_pages_markers() {
    // Tests page marker insertion in extracted content

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_pages_markers: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "pages": {
    "insert_page_markers": true
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_pages_markers: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_pages_markers: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_pages_markers: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_contains_any(&result, &["PAGE"]);
}

#[test]
fn test_config_pdf_hierarchy() {
    // Tests PDF hierarchy extraction config with block-level structure

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_pdf_hierarchy: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "pages": {
    "extract_pages": true
  },
  "pdf_options": {
    "hierarchy": {
      "enabled": true,
      "include_bbox": true
    }
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_pdf_hierarchy: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_pdf_hierarchy: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_pdf_hierarchy: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 50);
}

#[test]
fn test_config_postprocessor() {
    // Tests postprocessor config is accepted and extraction succeeds

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_postprocessor: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "postprocessor": {
    "enabled": true
  }
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for config_postprocessor: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_not_empty(&result);
}

#[test]
fn test_config_quality_disabled() {
    // Tests extraction with quality processing explicitly disabled

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_quality_disabled: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "enable_quality_processing": false
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for config_quality_disabled: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_content_not_empty(&result);
}

#[test]
fn test_config_quality_enabled() {
    // Tests quality scoring produces a score value in [0.0, 1.0]

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_quality_enabled: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "enable_quality_processing": true
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_quality_enabled: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_quality_enabled: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_quality_enabled: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
    assertions::assert_quality_score(&result, Some(true), Some(0.0), Some(1.0));
}

#[test]
fn test_config_structured_output() {
    // Tests structured (JSON) output format config

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_structured_output: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "output_format": "structured"
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(KreuzbergError::MissingDependency(dep)) => {
            println!("Skipping config_structured_output: missing dependency {dep}", dep = dep);
            return;
        }
        Err(KreuzbergError::UnsupportedFormat(fmt)) => {
            println!(
                "Skipping config_structured_output: unsupported format {fmt} (requires optional tool)",
                fmt = fmt
            );
            return;
        }
        Err(err) => panic!("Extraction failed for config_structured_output: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
}

#[test]
fn test_config_use_cache_false() {
    // Tests use_cache=false configuration option

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping config_use_cache_false: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "use_cache": false
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for config_use_cache_false: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
}

#[test]
fn test_output_format_bytes_markdown() {
    // Tests markdown output format via bytes extraction API

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping output_format_bytes_markdown: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "output_format": "markdown"
}"#,
    )
    .expect("Fixture config should deserialize");

    let file_bytes = std::fs::read(&document_path).expect("Failed to read document file");
    let mime_type = kreuzberg::detect_mime_type(&document_path, true).expect("Failed to detect MIME type");

    let result = match kreuzberg::extract_bytes_sync(&file_bytes, &mime_type, &config) {
        Err(err) => panic!("Extraction failed for output_format_bytes_markdown: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
}

#[test]
fn test_output_format_djot() {
    // Tests Djot output format

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping output_format_djot: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "output_format": "djot"
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for output_format_djot: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
}

#[test]
fn test_output_format_html() {
    // Tests HTML output format

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping output_format_html: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "output_format": "html"
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for output_format_html: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
}

#[test]
fn test_output_format_markdown() {
    // Tests Markdown output format

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping output_format_markdown: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "output_format": "markdown"
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for output_format_markdown: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
}

#[test]
fn test_output_format_plain() {
    // Tests Plain output format

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping output_format_plain: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "output_format": "plain"
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for output_format_plain: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
}

#[test]
fn test_result_format_element_based() {
    // Tests ElementBased result format with element assertions

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping result_format_element_based: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "result_format": "element_based"
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for result_format_element_based: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_elements(&result, Some(1), None);
}

#[test]
fn test_result_format_unified() {
    // Tests Unified result format (default)

    let document_path = resolve_document("pdf/fake_memo.pdf");
    if !document_path.exists() {
        println!(
            "Skipping result_format_unified: missing document at {}",
            document_path.display()
        );
        return;
    }
    let config: ExtractionConfig = serde_json::from_str(
        r#"{
  "result_format": "unified"
}"#,
    )
    .expect("Fixture config should deserialize");

    let result = match kreuzberg::extract_file_sync(&document_path, None, &config) {
        Err(err) => panic!("Extraction failed for result_format_unified: {err:?}"),
        Ok(result) => result,
    };

    assertions::assert_expected_mime(&result, &["application/pdf"]);
    assertions::assert_min_content_length(&result, 10);
}
