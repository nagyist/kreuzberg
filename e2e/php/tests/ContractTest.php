<?php

declare(strict_types=1);

// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
// To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang php

// Tests for contract fixtures.

namespace E2EPhp\Tests;

use E2EPhp\Helpers;
use Kreuzberg\Kreuzberg;
use PHPUnit\Framework\TestCase;

class ContractTest extends TestCase
{
    /**
     * Tests async batch bytes extraction API (batch_extract_bytes)
     */
    public function test_api_batch_bytes_async(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping api_batch_bytes_async: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(null);

        $kreuzberg = new Kreuzberg($config);
        $bytes = file_get_contents($documentPath);
        $mimeType = Kreuzberg::detectMimeType($bytes);
        $results = $kreuzberg->batchExtractBytes([$bytes], [$mimeType]);
        $result = $results[0];

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentContainsAny($result, ['May 5, 2023', 'Mallori']);
    }

    /**
     * Tests sync batch bytes extraction API (batch_extract_bytes_sync)
     */
    public function test_api_batch_bytes_sync(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping api_batch_bytes_sync: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(null);

        $kreuzberg = new Kreuzberg($config);
        $bytes = file_get_contents($documentPath);
        $mimeType = Kreuzberg::detectMimeType($bytes);
        $results = $kreuzberg->batchExtractBytes([$bytes], [$mimeType]);
        $result = $results[0];

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentContainsAny($result, ['May 5, 2023', 'Mallori']);
    }

    /**
     * Tests async batch file extraction API (batch_extract_file)
     */
    public function test_api_batch_file_async(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping api_batch_file_async: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(null);

        $kreuzberg = new Kreuzberg($config);
        $results = $kreuzberg->batchExtractFiles([$documentPath]);
        $result = $results[0];

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentContainsAny($result, ['May 5, 2023', 'Mallori']);
    }

    /**
     * Tests sync batch file extraction API (batch_extract_file_sync)
     */
    public function test_api_batch_file_sync(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping api_batch_file_sync: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(null);

        $kreuzberg = new Kreuzberg($config);
        $results = $kreuzberg->batchExtractFiles([$documentPath]);
        $result = $results[0];

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentContainsAny($result, ['May 5, 2023', 'Mallori']);
    }

    /**
     * Tests async bytes extraction API (extract_bytes)
     */
    public function test_api_extract_bytes_async(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping api_extract_bytes_async: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(null);

        $kreuzberg = new Kreuzberg($config);
        $bytes = file_get_contents($documentPath);
        $mimeType = Kreuzberg::detectMimeType($bytes);
        $result = $kreuzberg->extractBytes($bytes, $mimeType);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentContainsAny($result, ['May 5, 2023', 'Mallori']);
    }

    /**
     * Tests sync bytes extraction API (extract_bytes_sync)
     */
    public function test_api_extract_bytes_sync(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping api_extract_bytes_sync: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(null);

        $kreuzberg = new Kreuzberg($config);
        $bytes = file_get_contents($documentPath);
        $mimeType = Kreuzberg::detectMimeType($bytes);
        $result = $kreuzberg->extractBytes($bytes, $mimeType);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentContainsAny($result, ['May 5, 2023', 'Mallori']);
    }

    /**
     * Tests async file extraction API (extract_file)
     */
    public function test_api_extract_file_async(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping api_extract_file_async: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(null);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentContainsAny($result, ['May 5, 2023', 'Mallori']);
    }

    /**
     * Tests sync file extraction API (extract_file_sync)
     */
    public function test_api_extract_file_sync(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping api_extract_file_sync: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(null);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentContainsAny($result, ['May 5, 2023', 'Mallori']);
    }

    /**
     * Tests chunking configuration with chunk assertions
     */
    public function test_config_chunking(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_chunking: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['chunking' => ['max_chars' => 500, 'max_overlap' => 50]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertChunks($result, 1, null, true, null);
    }

    /**
     * Tests markdown-aware chunker type
     */
    public function test_config_chunking_markdown(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_chunking_markdown: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('chunking');

        $config = Helpers::buildConfig(['chunking' => ['chunker_type' => 'markdown', 'max_chars' => 500, 'max_overlap' => 50]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertChunks($result, 1, null, true, null);
    }

    /**
     * Tests chunking with very small chunk size produces more chunks
     */
    public function test_config_chunking_small(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_chunking_small: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('chunking');

        $config = Helpers::buildConfig(['chunking' => ['max_chars' => 100, 'max_overlap' => 20]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertChunks($result, 2, null, true, null);
    }

    /**
     * Tests djot output format converts content to djot markup
     */
    public function test_config_djot_content(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_djot_content: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('pdf');

        $config = Helpers::buildConfig(['output_format' => 'djot']);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
    }

    /**
     * Tests include_document_structure config produces document tree
     */
    public function test_config_document_structure(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_document_structure: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['include_document_structure' => true]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertDocument($result, true, 1, ['paragraph'], null);
    }

    /**
     * Tests document field is null when include_document_structure is false
     */
    public function test_config_document_structure_disabled(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_document_structure_disabled: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(null);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertDocument($result, false, null, null, null);
    }

    /**
     * Tests document structure extraction with heading nodes on a DOCX
     */
    public function test_config_document_structure_headings(): void
    {
        $documentPath = Helpers::resolveDocument('office/docx/headers.docx');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_document_structure_headings: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('office');

        $config = Helpers::buildConfig(['include_document_structure' => true]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/vnd.openxmlformats-officedocument.wordprocessingml.document']);
        Helpers::assertDocument($result, true, 1, ['heading', 'paragraph'], null);
    }

    /**
     * Tests document structure with DOCX heading-driven nesting
     */
    public function test_config_document_structure_with_headings(): void
    {
        $documentPath = Helpers::resolveDocument('docx/fake.docx');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_document_structure_with_headings: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['include_document_structure' => true]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/vnd.openxmlformats-officedocument.wordprocessingml.document']);
        Helpers::assertDocument($result, true, 1, null, null);
    }

    /**
     * Tests element-based result format with element type assertions on DOCX
     */
    public function test_config_element_types(): void
    {
        $documentPath = Helpers::resolveDocument('office/docx/headers.docx');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_element_types: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('office');

        $config = Helpers::buildConfig(['result_format' => 'element_based']);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/vnd.openxmlformats-officedocument.wordprocessingml.document']);
        Helpers::assertElements($result, 1, ['title', 'narrative_text']);
    }

    /**
     * Tests force_ocr configuration option
     */
    public function test_config_force_ocr(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_force_ocr: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('tesseract');

        $config = Helpers::buildConfig(['force_ocr' => true]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 5);
    }

    /**
     * Tests extraction with HTML conversion options configured
     */
    public function test_config_html_options(): void
    {
        $documentPath = Helpers::resolveDocument('html/complex_table.html');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_html_options: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['html_options' => ['include_links' => true]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['text/html']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentNotEmpty($result);
    }

    /**
     * Tests image extraction configuration with image assertions
     */
    public function test_config_images(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/embedded_images_tables.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_images: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['images' => ['extract_images' => true]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertImages($result, 1, null, null);
    }

    /**
     * Tests keyword extraction via YAKE algorithm
     */
    public function test_config_keywords(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_keywords: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('keywords-yake');

        $config = Helpers::buildConfig(['keywords' => ['algorithm' => 'yake', 'max_keywords' => 10]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertKeywords($result, true, 1, null);
    }

    /**
     * Tests language detection configuration
     */
    public function test_config_language_detection(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_language_detection: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['language_detection' => ['enabled' => true]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertDetectedLanguages($result, ['eng'], 0.5);
    }

    /**
     * Tests multi-language detection config
     */
    public function test_config_language_multi(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_language_multi: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('language-detection');

        $config = Helpers::buildConfig(['language_detection' => ['detect_multiple' => true, 'enabled' => true]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertDetectedLanguages($result, ['eng'], null);
    }

    /**
     * Tests page extraction and page marker configuration
     */
    public function test_config_pages(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_pages: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('pdf');

        $config = Helpers::buildConfig(['pages' => ['extract_pages' => true, 'insert_page_markers' => true]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentContainsAny($result, ['PAGE']);
    }

    /**
     * Tests page extraction config producing per-page content array
     */
    public function test_config_pages_extract(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_pages_extract: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('pdf');

        $config = Helpers::buildConfig(['pages' => ['extract_pages' => true]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertPages($result, 1, null);
    }

    /**
     * Tests page marker insertion in extracted content
     */
    public function test_config_pages_markers(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_pages_markers: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('pdf');

        $config = Helpers::buildConfig(['pages' => ['insert_page_markers' => true]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentContainsAny($result, ['PAGE']);
    }

    /**
     * Tests PDF hierarchy extraction config with block-level structure
     */
    public function test_config_pdf_hierarchy(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_pdf_hierarchy: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('pdf');

        $config = Helpers::buildConfig(['pages' => ['extract_pages' => true], 'pdf_options' => ['hierarchy' => ['enabled' => true, 'include_bbox' => true]]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 50);
    }

    /**
     * Tests postprocessor config is accepted and extraction succeeds
     */
    public function test_config_postprocessor(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_postprocessor: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['postprocessor' => ['enabled' => true]]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentNotEmpty($result);
    }

    /**
     * Tests extraction with quality processing explicitly disabled
     */
    public function test_config_quality_disabled(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_quality_disabled: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['enable_quality_processing' => false]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertContentNotEmpty($result);
    }

    /**
     * Tests quality scoring produces a score value in [0.0, 1.0]
     */
    public function test_config_quality_enabled(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_quality_enabled: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('quality');

        $config = Helpers::buildConfig(['enable_quality_processing' => true]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
        Helpers::assertQualityScore($result, true, 0, 1);
    }

    /**
     * Tests structured (JSON) output format config
     */
    public function test_config_structured_output(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_structured_output: missing document at ' . $documentPath);
        }

        Helpers::skipIfFeatureUnavailable('pdf');

        $config = Helpers::buildConfig(['output_format' => 'structured']);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
    }

    /**
     * Tests use_cache=false configuration option
     */
    public function test_config_use_cache_false(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping config_use_cache_false: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['use_cache' => false]);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
    }

    /**
     * Tests markdown output format via bytes extraction API
     */
    public function test_output_format_bytes_markdown(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping output_format_bytes_markdown: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['output_format' => 'markdown']);

        $kreuzberg = new Kreuzberg($config);
        $bytes = file_get_contents($documentPath);
        $mimeType = Kreuzberg::detectMimeType($bytes);
        $result = $kreuzberg->extractBytes($bytes, $mimeType);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
    }

    /**
     * Tests Djot output format
     */
    public function test_output_format_djot(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping output_format_djot: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['output_format' => 'djot']);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
    }

    /**
     * Tests HTML output format
     */
    public function test_output_format_html(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping output_format_html: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['output_format' => 'html']);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
    }

    /**
     * Tests Markdown output format
     */
    public function test_output_format_markdown(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping output_format_markdown: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['output_format' => 'markdown']);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
    }

    /**
     * Tests Plain output format
     */
    public function test_output_format_plain(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping output_format_plain: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['output_format' => 'plain']);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
    }

    /**
     * Tests ElementBased result format with element assertions
     */
    public function test_result_format_element_based(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping result_format_element_based: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['result_format' => 'element_based']);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertElements($result, 1, null);
    }

    /**
     * Tests Unified result format (default)
     */
    public function test_result_format_unified(): void
    {
        $documentPath = Helpers::resolveDocument('pdf/fake_memo.pdf');
        if (!file_exists($documentPath)) {
            $this->markTestSkipped('Skipping result_format_unified: missing document at ' . $documentPath);
        }

        $config = Helpers::buildConfig(['result_format' => 'unified']);

        $kreuzberg = new Kreuzberg($config);
        $result = $kreuzberg->extractFile($documentPath);

        Helpers::assertExpectedMime($result, ['application/pdf']);
        Helpers::assertMinContentLength($result, 10);
    }

}
