// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
// To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang wasm-deno

// Tests for contract fixtures. Run with: deno test --allow-read

import type { ExtractionResult } from "./helpers.ts";
import { assertions, buildConfig, extractBytes, initWasm, resolveDocument, shouldSkipFixture } from "./helpers.ts";

// Initialize WASM module once at module load time
await initWasm();

Deno.test("api_batch_bytes_async", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		// Batch async extraction - WASM simulates with single extraction
		const results = [await extractBytes(documentBytes, "application/octet-stream", config)];
		result = results[0];
	} catch (error) {
		if (shouldSkipFixture(error, "api_batch_bytes_async", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
});

Deno.test("api_batch_bytes_sync", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		// Batch sync extraction - WASM simulates with single extraction
		const results = [await extractBytes(documentBytes, "application/octet-stream", config)];
		result = results[0];
	} catch (error) {
		if (shouldSkipFixture(error, "api_batch_bytes_sync", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
});

Deno.test("api_batch_file_async", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		// Batch async extraction - WASM simulates with single extraction
		const results = [await extractBytes(documentBytes, "application/octet-stream", config)];
		result = results[0];
	} catch (error) {
		if (shouldSkipFixture(error, "api_batch_file_async", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
});

Deno.test("api_batch_file_sync", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		// Batch sync extraction - WASM simulates with single extraction
		const results = [await extractBytes(documentBytes, "application/octet-stream", config)];
		result = results[0];
	} catch (error) {
		if (shouldSkipFixture(error, "api_batch_file_sync", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
});

Deno.test("api_extract_bytes_async", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		// Async bytes extraction - native WASM pattern
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "api_extract_bytes_async", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
});

Deno.test("api_extract_bytes_sync", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		// Sync bytes extraction - WASM uses extractBytes with Uint8Array
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "api_extract_bytes_sync", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
});

Deno.test("api_extract_file_async", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		// Async file extraction - native WASM pattern
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "api_extract_file_async", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
});

Deno.test("api_extract_file_sync", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "api_extract_file_sync", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentContainsAny(result, ["May 5, 2023", "Mallori"]);
});

Deno.test("config_chunking", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ chunking: { max_chars: 500, max_overlap: 50 } });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_chunking", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertChunks(result, 1, null, true, null);
});

Deno.test("config_chunking_markdown", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ chunking: { chunker_type: "markdown", max_chars: 500, max_overlap: 50 } });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_chunking_markdown", ["chunking"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertChunks(result, 1, null, true, null);
});

Deno.test("config_chunking_small", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ chunking: { max_chars: 100, max_overlap: 20 } });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_chunking_small", ["chunking"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertChunks(result, 2, null, true, null);
});

Deno.test("config_djot_content", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ output_format: "djot" });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_djot_content", ["pdf"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertDjotContent(result, true, null);
});

Deno.test("config_document_structure", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ include_document_structure: true });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_document_structure", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertDocument(result, true, 1, ["paragraph"], null);
});

Deno.test("config_document_structure_disabled", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig(undefined);
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_document_structure_disabled", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertDocument(result, false, null, null, null);
});

Deno.test("config_document_structure_headings", { permissions: { read: true } }, async () => {
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("office/docx/headers.docx");
		const config = buildConfig({ include_document_structure: true });
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_document_structure_headings", ["office"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/vnd.openxmlformats-officedocument.wordprocessingml.document"]);
	assertions.assertDocument(result, true, 1, ["heading", "paragraph"], null);
});

Deno.test("config_document_structure_with_headings", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("docx/fake.docx");
	const config = buildConfig({ include_document_structure: true });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_document_structure_with_headings", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/vnd.openxmlformats-officedocument.wordprocessingml.document"]);
	assertions.assertDocument(result, true, 1, null, null);
});

Deno.test("config_element_types", { permissions: { read: true } }, async () => {
	let result: ExtractionResult | null = null;
	try {
		const documentBytes = await resolveDocument("office/docx/headers.docx");
		const config = buildConfig({ result_format: "element_based" });
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_element_types", ["office"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/vnd.openxmlformats-officedocument.wordprocessingml.document"]);
	assertions.assertElements(result, 1, ["title", "narrative_text"]);
});

Deno.test("config_force_ocr", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ force_ocr: true });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_force_ocr", ["tesseract"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 5);
});

Deno.test("config_html_options", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("html/complex_table.html");
	const config = buildConfig({ html_options: { include_links: true } });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_html_options", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["text/html"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentNotEmpty(result);
});

Deno.test("config_images", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/embedded_images_tables.pdf");
	const config = buildConfig({ images: { extract_images: true } });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_images", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertImages(result, 1, null, null);
});

Deno.test("config_language_detection", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ language_detection: { enabled: true } });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_language_detection", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertDetectedLanguages(result, ["eng"], 0.5);
});

Deno.test("config_language_multi", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ language_detection: { detect_multiple: true, enabled: true } });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_language_multi", ["language-detection"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertDetectedLanguages(result, ["eng"], null);
});

Deno.test("config_pages", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ pages: { extract_pages: true, insert_page_markers: true } });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_pages", ["pdf"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentContainsAny(result, ["PAGE"]);
});

Deno.test("config_pages_extract", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ pages: { extract_pages: true } });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_pages_extract", ["pdf"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertPages(result, 1, null);
});

Deno.test("config_pages_markers", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ pages: { insert_page_markers: true } });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_pages_markers", ["pdf"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentContainsAny(result, ["PAGE"]);
});

Deno.test("config_pdf_hierarchy", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({
		pages: { extract_pages: true },
		pdf_options: { hierarchy: { enabled: true, include_bbox: true } },
	});
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_pdf_hierarchy", ["pdf"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 50);
});

Deno.test("config_postprocessor", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ postprocessor: { enabled: true } });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_postprocessor", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentNotEmpty(result);
});

Deno.test("config_quality_disabled", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ enable_quality_processing: false });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_quality_disabled", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertContentNotEmpty(result);
});

Deno.test("config_quality_enabled", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ enable_quality_processing: true });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_quality_enabled", ["quality"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
	assertions.assertQualityScore(result, true, 0, 1);
});

Deno.test("config_structured_output", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ output_format: "structured" });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_structured_output", ["pdf"], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
});

Deno.test("config_use_cache_false", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ use_cache: false });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "config_use_cache_false", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
});

Deno.test("output_format_bytes_markdown", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ output_format: "markdown" });
	let result: ExtractionResult | null = null;
	try {
		// Sync bytes extraction - WASM uses extractBytes with Uint8Array
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "output_format_bytes_markdown", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
});

Deno.test("output_format_djot", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ output_format: "djot" });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "output_format_djot", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
});

Deno.test("output_format_html", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ output_format: "html" });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "output_format_html", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
});

Deno.test("output_format_markdown", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ output_format: "markdown" });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "output_format_markdown", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
});

Deno.test("output_format_plain", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ output_format: "plain" });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "output_format_plain", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
});

Deno.test("result_format_element_based", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ result_format: "element_based" });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "result_format_element_based", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertElements(result, 1, null);
});

Deno.test("result_format_unified", { permissions: { read: true } }, async () => {
	const documentBytes = await resolveDocument("pdf/fake_memo.pdf");
	const config = buildConfig({ result_format: "unified" });
	let result: ExtractionResult | null = null;
	try {
		// Sync file extraction - WASM uses extractBytes with pre-read bytes
		result = await extractBytes(documentBytes, "application/octet-stream", config);
	} catch (error) {
		if (shouldSkipFixture(error, "result_format_unified", [], undefined)) {
			return;
		}
		throw error;
	}
	if (result === null) {
		return;
	}
	assertions.assertExpectedMime(result, ["application/pdf"]);
	assertions.assertMinContentLength(result, 10);
});
