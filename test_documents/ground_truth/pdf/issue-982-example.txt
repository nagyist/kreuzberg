# Creativity in Machine Learning

Martin Thoma
E-Mail: info@martin-thoma.de

## Abstract

Recent machine learning techniques can be modified to produce creative results. Those results did not exist before; it is not a trivial combination of the data which was fed into the machine learning system. The obtained results come in multiple forms: As images, as text and as audio.

This paper gives a high level overview of how they are created and gives some examples. It is meant to be a summary of the current work and give people who are new to machine learning some starting points.

## I. INTRODUCTION

According to [Gad06] creativity is "the ability to use your imagination to produce new ideas, make things etc." and imagination is "the ability to form pictures or ideas in your mind".

Recent advances in machine learning produce results which the author would intuitively call creative. A high-level overview over several of those algorithms are described in the following. This paper is structured as follows: Section II introduces the reader on a very simple and superficial level to machine learning, Section III gives examples of creativity with images, Section IV gives examples of machines producing textual content, and Section V gives examples of machine learning and music. A discussion follows in Section VI.

## II. BASICS OF MACHINE LEARNING

The traditional approach of solving problems with software is to program machines to do so. The task is divided in as simple sub-tasks as possible, the subtasks are analyzed and the machine is instructed to process the input with human-designed algorithms to produce the desired output. However, for some tasks like object recognition this approach is not feasible. There are way to many different objects, different lighting situations, variations in rotation and the arrangement of a scene for a human to think of all of them and model them. But with the internet, cheap computers, cameras, crowd-sourcing platforms like Wikipedia and lots of Websites, services like Amazon Mechanical Turk and several other changes in the past decades a lot of data has become available. The idea of machine learning is to make use of this data.

A formal definition of the field of Machine Learning is given by Tom Mitchel [Mit97]:

A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.

This means that machine learning programs adjust internal parameters to fit the data they are given. Those computer programs are still developed by software developers, but the developer writes them in a way which makes it possible to adjust them without having to re-program everything. Machine learning programs should generally improve when they are fed with more data.

The field of machine learning is related to statistics. Some algorithms directly try to find models which are based on well-known distribution assumptions of the developer, others are more general.

A common misunderstanding of people who are not related in this field is that the developers don't understand what their machine learning program is doing. It is understood very well in the sense that the developer, given only a pen, lots of paper and a calculator could calculate the same result as the machine does when he gets the same data. And lots of time, of course. It is not understood in the sense that it is hard to make predictions how the algorithm behaves without actually trying it. However, this is similar to expecting from an electrical engineer to explain how a computer works. The electrical engineer could probably get the knowledge he needs to do so, but the amount of time required to understand such a complex system from basic building blocks is a time-intensive and difficult task.

An important group of machine learning algorithms was inspired by biological neurons and are thus called artificial neural networks. Those networks are based on mathematical functions called artificial neurons which take n ∈ N numbers x1, . . . , xn ∈ R as input, multiply them with weights w1, . . . , wn ∈ R, add them and apply a so called activation function ϕ as visualized in Figure 1(a). One example of such an activation function is the sigmoid function ϕ(x) = 1/(1+e−x). Those functions act as building blocks for more complex systems as they can be chained and grouped in layers as visualized in Figure 1(b). The interesting question is how the parameters wi are learned. This is usually done by an optimization technique called gradient descent. The gradient descent algorithm takes a function which has to be derivable, starts at any point of the surface of this error function and makes a step in the direction which goes downwards. Hence it tries to find a minimum of this high-dimensional function.

There is, of course, a lot more to say about machine learning. The interested reader might want to read the introduction given by Mitchell [Mit97].

## III. IMAGE DATA

Applying a simple neural network on image data directly can work, but the number of parameters gets extraordinary large. One would take one neuron per pixel and channel. This means for 500 px×500 px RGB images one would get 750,000 input signals. To approach this problem, so called Convolutional Neural Networks (CNNs) were introduced. Instead of learning the full connection between the input layer and the first hidden layer, those networks make use of convolution layers. Convolution layers learn a convolution; this means they learn the weights of an image filter. An additional advantage is that CNNs make use of spacial relationships of the pixels instead of flattening the image to a stream of single numbers.

An excellent introduction into CNNs is given by [Nie15].

### A. Google DeepDream

The gradient descent algorithm which optimizes most of the parameters in neural networks is well-understood. However, the effect it has on the recognition system is difficult to estimate. [MOT15] proposes a technique to analyze the weights learned by such a network. A similar idea was applied by [VKMT13].

For example, consider a neural network which was trained to recognize various images like bananas. This technique turns the network upside down and starts with random noise. To analyze what the network considers bananas to look like, the random noise image is gradually tweaked so that it generates the output "banana". Additionally, the changes can be restricted in a way that the statistics of the input image have to be similar to natural images. One example of this is that neighboring pixels are correlated.

Another technique is to amplify the output of layers. This was described in [MOT15]:

We ask the network: "Whatever you see there, I want more of it!" This creates a feedback loop: if a cloud looks a little bit like a bird, the network will make it look more like a bird. This in turn will make the network recognize the bird even more strongly on the next pass and so forth, until a highly detailed bird appears, seemingly out of nowhere.

The name "Inceptionism" in the title of [MOT15] comes from the science-fiction movie "Inception" (2010). One reason it might be chosen is because neural networks are structured in layers. Recent publications tend to have more and more layers [HZRS15]. The used jargon is to say they get "deeper". As this technique as published by Google engineers, the technique is called Google DeepDream.

It has become famous in the internet [Red]. Usually, the images are generated in iterations and in each iteration it is zoomed into the image.

Images and videos published by the Google engineers can be seen at [goo15]. Figure 2 shows the original image from which Figure 3 was created with the deep dream algorithm.

### B. Artistic Style Imitation

A key idea of neural networks is that they learn different representations of the data in each layer. In the case of CNNs, this can easily be visualized as it was done in various papers [ZF14]. Usually, one finds that the network learned to build edge detectors in the first layer and more complex structures in the upper layers.

Gatys, Ecker and Bethge showed in [GEB15] that with a clever choice of features it is possible to separate the general style of an image in terms of local image appearance from the content of an image. They support their claim by applying the style of different artists to an arbitrary image of their choice.

This artistic style imitation can be seen itself as creative work. An example is given by Figure 4. The code which created this example is available under [Joh16].

Something similar was done by [SPB+14], where the style of a portrait photograph was transferred to another photograph. A demo can be seen on [Shi14].

### C. Drawing Robots

Patrick Tresset and Frdric Fol Leymarie created a system called AIKON (Automatic IKONic drawing) which can automatically generated sketches for portraits [TL05]. AIKON takes a digital photograph, detects faces on them and sketches them with a pen-plotter.

Tresset and Leymaire use k-means clustering [KMN+02] to segment regions of the photograph with similar color which, in turn, will get a similar shading.

Such a drawing robot could apply machine learning techniques known from computer vision for detecting the human. It could apply self-learning techniques to draw results most similar to the artists impression of the image. However, the system described in [TL05] seems not to be a machine learning computer program according to the definition by Tom Mitchell [Mit97].

## IV. TEXT DATA

Digital text is the first form of natural communication which involved computers. It is used in the form of chats, websites, on collaborative projects like Wikipedia, in scientific literature. Of course, it was used in pre-digital times, too: In newspaper, in novels, in dramas, in religious texts like the bible, in books for education, in notes from conversations.

This list could be continued and most of these kinds of texts are now available in digital form. This digital form can be used to teach machines to generate similar texts.

The most simple language model which is of use is an n-gram model. This model makes use of sequences of the length n to model language. It can be used to get the probability of a third word, given the previous two words. This way, a complete text can be generated word by word. Refinements and extensions to this model are discussed in the field of Natural Language Processing (NLP).

However, there are much more sophisticated models. One of those are character predictors based on Recurrent Neural Networks (RNNs). Those character predictors take a sequence of characters as input and predict the next character. In that sense they are similar to the n-gram model, but operate on a lower level. Using such a predictor, one can generate texts character by character. If the model is good, the text can have the correct punctuation. This would not be possible with a word predictor.

Character predictors can be implemented with RNNs. In contrast to standard feed-forward neural networks like multilayer Perceptrons (MLPs) which was shown in Figure 1(b), those networks are trained to take their output at some point as well as the normal input. This means they can keep some information over time. One of the most common variant to implement RNNs is by using so called Long short-term memory (LSTM) cells [HS97].

Recurrent networks apply two main ideas in order to learn: The first is called unrolling and means that an recurrent network is imagined to be an infinite network over time. At each time step the recurrent neurons get duplicated. The second idea is weight sharing which means that those unrolled neurons share the same weight.

### A. Similar Texts Generation

Karpathy trained multiple character RNNs on different datasets and gave an excellent introduction [Kar15b]. He trained it on Paul Graham's essays, all the works of Shakespeare, the Hutter Prize [hut] 100 MB dataset of raw Wikipedia articles, the raw LATEX source file of a book about algebraic stacks and geometry and Linux C code.

With that training data, the models can generate similar texts. New works which look like Shakespeare plays, new Wikipedia articles, new Linux code and new papers about algebraic geometry can thus automatically be generated. At a first glance, they do look authentic. The syntax was mostly used correctly, the formatting looks as expected, the sentences are grammatically correct. However, when one looks at the broader context it is easy to recognize that the algorithm has no insight in what it is doing. It does match patterns really well, but it fails to follow a central theme. In the context of C code this means that new variables are introduced, but not used. At the same time, variables which were not declared are used. In the context of Shakespear plays this means that a lot of new characters are introduced, but they don't speak with each other or about each other.

The code used to generate these examples is available and ready to use through [Kar15a]. A couple of examples are in Section A.

### B. Chatbots

Chatbots are computer programs which participate in chat rooms as autonomous agents. This means they have similar permissions and possibilities as usual human users have, but users can trigger a set of commands to make the bot give them valuable information or features.

A special category of chatbots are such bots which actively participate in the conversation, which is usually not the case. One of the earliest programs in this category is ELIZA, a bot created by Joseph Weizenbaum in the 1960s [Wei76]. This program had a set of patterns implemented to which it would reply in a seemingly smart way in a psychologists fashion. This means quite often the program would simply repeat the last sentence and add something meaningless like "How do you feel about it?". According to [Cur14], Weizenbaum once found his secretary — who was aware of the fact that this is a computer program — chatting with the machine. When he looked over her shoulder, she asked him "would you mind leaving the room".

Today, much more sophisticated chatbots exist. They make use of the vast amount of data which is available by millions of Wikipedia articles, chat protocols, websites, help desk protocols, subtitles of movies as well as the astonishing increase in computing power to train RNNs and language models similar to the ones described before.

Interesting results like the following were obtained by [VL15]:
