______________________________________________________________________

## priority: high

# WebAssembly - wasm-bindgen Browser/Node/Deno/Workers

**wasm-bindgen · wasm-pack · Browser · Node.js · Deno · Cloudflare Workers · Async/await · 80%+ coverage**

- wasm-bindgen for Rust ↔ JavaScript FFI; wasm-pack for bundling
- Support all platforms: browser (ES modules), Node.js (CommonJS/ESM), Deno, Cloudflare Workers
- Bundle size optimization: tree-shaking, code splitting, dynamic imports
- Async operations via JavaScript Promises; use #[wasm_bindgen] for bridge
- Single-threaded WASM constraint (no threads); use Web Workers for parallelism
- npm package publishing with dual CommonJS/ESM outputs; package.json exports field
- TypeScript type definitions auto-generated; strict types required
- Testing: wasm-pack test, vitest for integration tests, 80%+ coverage
- Never: blocking operations in WASM, synchronous I/O, shared mutable state
- Use Haiku 4.5 for wasm-bindings-engineer tasks and cross-platform issues

## wasm-bindgen Crate Structure

WASM crates follow the pattern `crates/{module_name}-wasm`:

```
crates/my-module-wasm/
  ├── Cargo.toml          # [lib] cdylib, wasm-bindgen dependencies
  ├── src/
  │   └── lib.rs          # #[wasm_bindgen] exports, js! macros
  ├── pkg/                # Generated by wasm-pack (gitignored)
  │   ├── package.json
  │   ├── {module}.d.ts
  │   ├── {module}_bg.d.ts
  │   └── {module}.js
  └── tests/
      └── web.rs         # Browser tests via wasm-pack test
```

**Requirements:**

- Cargo.toml with [lib] cdylib and crate-type = ["cdylib"]
- wasm-bindgen dependency pinned to stable version
- All public exports use #[wasm_bindgen] attribute
- No #![deny(warnings)]; allow specific lints only
- Keep lib.rs under 500 lines; split into modules

## wasm-pack Configuration

Build configuration for multiple targets:

```toml
[package]
name = "my-module-wasm"
version = "0.1.0"

[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2"
wasm-bindgen-futures = "0.4"
web-sys = { version = "0.3", features = ["Window", "Document"] }
js-sys = "0.3"

[dev-dependencies]
wasm-bindgen-test = "1"
```

**wasm-pack build targets:**

```bash
# Browser (ES modules)
wasm-pack build --target web

# Node.js (CommonJS)
wasm-pack build --target nodejs

# Bundler (webpack/vite)
wasm-pack build --target bundler

# Deno
wasm-pack build --target deno
```

**Requirements:**

- Single source builds all targets via profile configuration
- profile.release: opt-level = "z", lto = true (minimize size)
- No platform-specific code; feature gates only when necessary
- Vendored dependencies checked; minimize transitive deps

## Cross-Platform API Design

Unified API across browser, Node.js, Deno, Cloudflare Workers:

```rust
#[wasm_bindgen]
pub struct Processor {
    // Internal state
}

#[wasm_bindgen]
impl Processor {
    #[wasm_bindgen(constructor)]
    pub fn new(config: JsValue) -> Result<Processor, JsValue> {
        // Parse JS config to Rust struct
        Ok(Processor { /* ... */ })
    }

    #[wasm_bindgen]
    pub fn process(&self, input: &str) -> Result<String, JsValue> {
        // Process and return result or error
        Ok(result)
    }

    #[wasm_bindgen]
    pub async fn process_async(&self, input: &str) -> Result<JsValue, JsValue> {
        // Async operation
        Ok(result)
    }
}
```

**Requirements:**

- Consistent method signatures across all targets
- Result\<T, JsValue> for all fallible operations
- No platform detection in Rust code (#[cfg(target_os)] only for features)
- Error messages serializable to JavaScript strings
- Constructor patterns for complex initialization

## Async Operations & Promises

Async code in WASM must integrate with JavaScript Promises:

```rust
use wasm_bindgen_futures::JsFuture;
use web_sys::window;

#[wasm_bindgen]
pub async fn fetch_data(url: &str) -> Result<JsValue, JsValue> {
    let window = web_sys::window().ok_or("No window object")?;
    let fetch_promise = window.fetch_with_str(url);

    let response = JsFuture::from(fetch_promise)
        .await
        .map_err(|_| "Fetch failed")?;

    Ok(response)
}
```

**Requirements:**

- Use wasm-bindgen-futures for async/await
- All async functions return Promise<T> or Promise\<Result\<T, Error>>
- No blocking I/O; all I/O must be async
- Timeouts and cancellation via AbortController
- Document async behavior in TypeScript types

## Bundle Size Optimization

WASM binaries must be as small as possible:

```toml
[profile.release]
opt-level = "z"     # Optimize for size
lto = true          # Link-time optimization
codegen-units = 1   # Single codegen unit for better optimization
strip = true        # Strip symbols (if not needed for debugging)
```

**Size reduction techniques:**

1. **Tree-shaking**: Unused exports removed by bundler
1. **Code splitting**: Dynamic imports for lazy loading
1. **Feature gates**: Compile only needed functionality
1. **Minimal dependencies**: Avoid large transitive deps

**Example: Dynamic imports in JavaScript**

```javascript
// Only load WASM when needed
async function getProcessor() {
  const { Processor } = await import('./pkg/my_module_wasm.js');
  return new Processor();
}
```

**Requirements:**

- Binary size < 500KB for typical use cases (gzipped)
- Measure with: wc -c pkg/my_module_wasm_bg.wasm
- Profile dependencies: cargo tree, identify large deps
- Use wasm-opt for post-build optimization

## Browser Support

Browser-specific considerations:

```javascript
// ES module import (modern browsers)
import { Processor } from './pkg/my_module_wasm.js';

// Works in all modern browsers (Chrome 89+, Firefox 79+, Safari 14.1+)
const processor = new Processor();
const result = processor.process("input");

// For older browsers, bundle with fallback or polyfill
```

**Requirements:**

- No IE11 support (unsupported by WebAssembly spec)
- Modern browser features: ES2020+, BigInt, SharedArrayBuffer
- CORS headers for .wasm file download
- Proper MIME type: application/wasm
- Source maps for debugging (wasm-pack --dev)

## Node.js & Deno Integration

Node.js and Deno have different module systems:

```javascript
// Node.js (CommonJS)
const { Processor } = require('./pkg/my_module_wasm.js');

// Node.js (ESM)
import { Processor } from './pkg/my_module_wasm.js';
```

```javascript
// Deno
import { Processor } from './pkg/my_module_wasm.js';

// Deno also supports npm: prefix
import { Processor } from 'npm:my-module-wasm@1.0.0';
```

**Requirements:**

- CommonJS and ESM both supported via package.json exports
- .wasm file must be readable from filesystem (require.resolve)
- Deno: import map for npm packages
- No Node.js-specific APIs (fs, path) in WASM code

## Cloudflare Workers Support

Workers run WASM in edge environment with constraints:

```rust
#[wasm_bindgen]
pub fn process_request(body: &str) -> Result<String, JsValue> {
    // No access to filesystem, network is limited
    // Pure computation only
    let result = expensive_computation(body)?;
    Ok(result)
}
```

**Requirements:**

- No I/O operations (filesystem, network) in Rust code
- Pure computation only; delegate I/O to JavaScript
- Keep initialization fast (cold start constraint)
- Memory-efficient (limited Worker memory)
- Test with wrangler dev locally

## Single-Threaded WASM Constraints

WebAssembly is fundamentally single-threaded:

**What DOESN'T work:**

```rust
// This will panic in browsers
use std::thread;
thread::spawn(|| {
    expensive_computation();
});
```

**What DOES work - Web Workers:**

```javascript
// main.js
const worker = new Worker('worker.js');
worker.postMessage({data: "process"});
worker.onmessage = (event) => {
  console.log('Result:', event.data);
};

// worker.js
import { Processor } from './pkg/my_module_wasm.js';
self.onmessage = (event) => {
  const processor = new Processor();
  const result = processor.process(event.data);
  self.postMessage(result);
};
```

**Requirements:**

- No std::thread usage in WASM code
- Parallelism via Web Workers for browser
- Parallelism via Worker Threads for Node.js
- Document threading model in README
- Test single-threaded operation thoroughly

## TypeScript Type Definitions

wasm-pack auto-generates TypeScript definitions:

```typescript
// Automatically generated from #[wasm_bindgen]
export class Processor {
  constructor(config: any);
  process(input: string): string;
  process_async(input: string): Promise<string>;
}

export function free_wasm_memory(): void;
```

**Requirements:**

- Never manually edit .d.ts files (regenerated by wasm-pack)
- Types must match Rust #[wasm_bindgen] signatures
- Use typescript strict mode when consuming
- All public Rust APIs must have TypeScript equivalents
- Document any TypeScript-specific behavior

## npm Package Structure

Published npm packages support all platforms:

```json
{
  "name": "my-module-wasm",
  "version": "0.1.0",
  "type": "module",
  "exports": {
    ".": {
      "import": "./pkg/my_module_wasm.js",
      "require": "./pkg/my_module_wasm.js"
    }
  },
  "files": ["pkg/"],
  "types": "./pkg/my_module_wasm.d.ts",
  "main": "./pkg/my_module_wasm.js"
}
```

**Publishing workflow:**

```bash
# Build for all targets
wasm-pack build --target bundler --release
wasm-pack build --target nodejs --release
wasm-pack build --target web --release

# Publish to npm
npm publish
```

**Requirements:**

- package.json exports field for multi-target support
- pkg/ directory contains all generated files
- .wasm binary included in npm package
- CHANGELOG documenting breaking changes
- Semver versioning: MAJOR.MINOR.PATCH

## Testing

Testing WASM across platforms:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_process() {
        let processor = Processor::new(JsValue::NULL).unwrap();
        assert_eq!(processor.process("input").unwrap(), "expected");
    }
}
```

Run tests:

```bash
# Browser tests
wasm-pack test --headless --firefox

# Rust unit tests
cargo test
```

**Integration tests in JavaScript:**

```typescript
import { Processor } from './pkg/my_module_wasm.js';

describe('Processor', () => {
  it('processes input correctly', () => {
    const processor = new Processor();
    const result = processor.process('input');
    expect(result).toBe('expected');
  });

  it('handles async operations', async () => {
    const processor = new Processor();
    const result = await processor.process_async('input');
    expect(result).toBe('expected');
  });
});
```

**Requirements:**

- 80%+ code coverage across Rust and JavaScript
- Test all public APIs
- Test error cases and edge cases
- Test async operations with proper waiting
- Test across all target platforms (browser, Node, Deno, Workers)

## Error Handling

All operations return Result or throw JavaScript errors:

```rust
#[wasm_bindgen]
pub fn process(input: &str) -> Result<String, JsValue> {
    if input.is_empty() {
        return Err(JsValue::from_str("Input cannot be empty"));
    }

    let result = expensive_operation(input)
        .map_err(|e| JsValue::from_str(&format!("Error: {}", e)))?;

    Ok(result)
}
```

**JavaScript consumption:**

```javascript
try {
  const result = processor.process('');
} catch (error) {
  console.error('Processing failed:', error);
}
```

**Requirements:**

- Result\<T, JsValue> for fallible operations
- Clear error messages describing what went wrong
- Never panic!() in production code
- Handle all edge cases before returning to JavaScript
- Document error conditions in JSDoc comments

## Anti-Patterns to Avoid

**Never do this:**

1. Blocking operations in WASM (computation only)
1. Mutable global state shared with JavaScript
1. Panicking instead of returning Err()
1. Large monolithic WASM binary (split into modules)
1. Synchronous I/O operations
1. Assuming SharedArrayBuffer availability
1. Using threads without Web Workers coordination
1. Ignoring bundle size; always measure

**Good alternatives:**

1. Delegate I/O to JavaScript; WASM computes only
1. Pass data in/out, no shared mutable state
1. Return Result\<T, JsValue> for all fallible ops
1. Use dynamic imports; split code by feature
1. All I/O async via Promises
1. Document SharedArrayBuffer assumptions; test availability
1. Use Web/Worker Threads for parallelism; coordinate via message passing
1. Measure size continuously; optimize bundling

## Performance Considerations

Optimize WASM performance:

```rust
// Good: Pure computation, no allocations
#[wasm_bindgen]
pub fn hash(input: &str) -> String {
    // Fast algorithm, minimal allocations
    compute_hash(input)
}

// Avoid: Large allocations per call
#[wasm_bindgen]
pub fn process_large_data(data: &[u8]) -> Vec<u8> {
    // Consider: Pre-allocate, reuse buffers
    vec![/* large output */]
}
```

**Requirements:**

- Profile with devtools; identify bottlenecks
- Minimize JavaScript ↔ WASM boundary crossings
- Batch operations when possible
- Use typed arrays for large data transfer
- Document performance characteristics

## Agent References

For WASM-specific binding engineering:

- **wasm-bindings-engineer**: Cross-platform architecture, async patterns, bundle optimization, Worker coordination
- **Use for**: WASM API design, async/Promise integration, platform-specific issues
- **Reference in commits**: Consult wasm-bindings-engineer for binding architecture across platforms
