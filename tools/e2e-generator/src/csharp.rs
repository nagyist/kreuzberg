use crate::fixtures::{Assertions, ExtractionMethod, Fixture, InputType, PluginAssertions, PluginTestSpec};
use anyhow::{Context, Result};
use camino::Utf8Path;
use itertools::Itertools;
use serde_json::{Map, Value};
use std::fmt::Write as _;
use std::fs;

const CSHARP_HELPERS_TEMPLATE: &str = r#"// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Nodes;
using Kreuzberg;
using Xunit;
using Xunit.Sdk;

namespace Kreuzberg.E2E;

public static class TestHelpers
{
    private static readonly string WorkspaceRoot = ResolveWorkspaceRoot();
    private static readonly string TestDocuments = Path.Combine(WorkspaceRoot, "test_documents");

    static TestHelpers()
    {
        EnsureNativeLibraryLoaded();
    }

    private static string ResolveWorkspaceRoot()
    {
        var dir = AppContext.BaseDirectory;
        for (var i = 0; i < 8 && dir is not null; i++)
        {
            var candidate = dir!;
            if (File.Exists(Path.Combine(candidate, "Cargo.toml")) &&
                Directory.Exists(Path.Combine(candidate, "test_documents")))
            {
                return candidate;
            }
            dir = Directory.GetParent(candidate)?.FullName;
        }

        // Fallback to legacy two-levels-up resolution
        var cwd = Directory.GetCurrentDirectory();
        return Path.GetFullPath(Path.Combine(cwd, "..", ".."));
    }

    private static void EnsureNativeLibraryLoaded()
    {
        var candidates = new[]
        {
            Path.Combine(WorkspaceRoot, "target", "release", LibraryFileName()),
            Path.Combine(WorkspaceRoot, "target", "debug", LibraryFileName()),
        };

        foreach (var candidate in candidates)
        {
            if (File.Exists(candidate))
            {
                NativeLibrary.Load(candidate);
                return;
            }
        }

        throw new XunitException($"Native library not found. Expected at: {string.Join(", ", candidates)}");
    }

    private static string LibraryFileName()
    {
        if (OperatingSystem.IsWindows())
        {
            return "kreuzberg_ffi.dll";
        }
        if (OperatingSystem.IsMacOS())
        {
            return "libkreuzberg_ffi.dylib";
        }
        return "libkreuzberg_ffi.so";
    }

    public static string EnsureDocument(string relative, bool skipIfMissing)
    {
        var path = Path.Combine(TestDocuments, relative.Replace('/', Path.DirectorySeparatorChar));
        if (!File.Exists(path))
        {
            if (skipIfMissing)
            {
                throw new XunitException($"Missing document {path}");
            }
            throw new FileNotFoundException($"Document unavailable: {path}");
        }
        return path;
    }

    public static void SkipIfLegacyOfficeDisabled(string relativePath)
    {
        var flag = Environment.GetEnvironmentVariable("KREUZBERG_SKIP_LEGACY_OFFICE");
        if (string.IsNullOrWhiteSpace(flag) || !OperatingSystem.IsWindows())
        {
            return;
        }
        var ext = Path.GetExtension(relativePath).ToLowerInvariant();
        if (ext == ".ppt" || ext == ".doc" || ext == ".xls")
        {
            throw new Xunit.SkipException();
        }
    }

    public static void SkipIfOfficeTestOnWindows(string relativePath)
    {
        // Office tests timeout on Windows
        if (OperatingSystem.IsWindows())
        {
            var ext = Path.GetExtension(relativePath).ToLowerInvariant();
            var isOfficeFormat = ext is ".docx" or ".pptx" or ".xlsx" or ".doc" or ".ppt" or ".xls";
            if (isOfficeFormat)
            {
                throw new Xunit.SkipException();
            }
        }
    }

    public static void SkipIfPaddleOcrUnavailable()
    {
        SkipIfFeatureUnavailable("paddle-ocr");
    }

    public static void SkipIfFeatureUnavailable(string feature)
    {
        var envVar = "KREUZBERG_" + feature.Replace("-", "_").ToUpperInvariant() + "_AVAILABLE";
        var flag = Environment.GetEnvironmentVariable(envVar);
        if (string.IsNullOrWhiteSpace(flag) || flag == "0" || flag.Equals("false", StringComparison.OrdinalIgnoreCase))
        {
            throw new Xunit.SkipException();
        }
    }

    public static ExtractionConfig? BuildConfig(string? configJson)
    {
        if (string.IsNullOrWhiteSpace(configJson))
        {
            return null;
        }
        return Serialization.ParseConfig(configJson!);
    }

    public static ExtractionResult RunExtraction(string relativePath, string? configJson)
    {
        var documentPath = EnsureDocument(relativePath, true);
        var config = BuildConfig(configJson);
        return KreuzbergClient.ExtractFileSync(documentPath, config);
    }

    public static void AssertExpectedMime(ExtractionResult result, IEnumerable<string> expected)
    {
        var tokens = expected.ToArray();
        if (tokens.Length == 0)
        {
            return;
        }
        foreach (var token in tokens)
        {
            if (result.MimeType.Contains(token, StringComparison.OrdinalIgnoreCase))
            {
                return;
            }
        }
        throw new XunitException($"Expected MIME to include one of [{string.Join(", ", tokens)}], got {result.MimeType}");
    }

    public static void AssertMinContentLength(ExtractionResult result, int minimum)
    {
        if (result.Content.Length < minimum)
        {
            throw new XunitException($"Expected content length >= {minimum}, got {result.Content.Length}");
        }
    }

    public static void AssertMaxContentLength(ExtractionResult result, int maximum)
    {
        if (result.Content.Length > maximum)
        {
            throw new XunitException($"Expected content length <= {maximum}, got {result.Content.Length}");
        }
    }

    public static void AssertContentContainsAny(ExtractionResult result, IEnumerable<string> snippets)
    {
        var list = snippets.ToArray();
        if (list.Length == 0)
        {
            return;
        }
        var lowered = result.Content.ToLowerInvariant();
        foreach (var snippet in list)
        {
            if (lowered.Contains(snippet.ToLowerInvariant()))
            {
                return;
            }
        }
        throw new XunitException($"Expected content to contain any of [{string.Join(", ", list)}]");
    }

    public static void AssertContentContainsAll(ExtractionResult result, IEnumerable<string> snippets)
    {
        var list = snippets.ToArray();
        if (list.Length == 0)
        {
            return;
        }
        var lowered = result.Content.ToLowerInvariant();
        var missing = list.Where(snippet => !lowered.Contains(snippet.ToLowerInvariant())).ToArray();
        if (missing.Length > 0)
        {
            throw new XunitException($"Expected content to contain all snippets, missing: [{string.Join(", ", missing)}]");
        }
    }

    public static void AssertTableCount(ExtractionResult result, int? min, int? max)
    {
        var count = result.Tables?.Count ?? 0;
        if (min.HasValue && count < min.Value)
        {
            throw new XunitException($"Expected at least {min.Value} tables, got {count}");
        }
        if (max.HasValue && count > max.Value)
        {
            throw new XunitException($"Expected at most {max.Value} tables, got {count}");
        }
    }

    public static void AssertDetectedLanguages(ExtractionResult result, IEnumerable<string> expected, double? minConfidence)
    {
        var expectedList = expected.ToArray();
        if (expectedList.Length == 0)
        {
            return;
        }
        var langs = result.DetectedLanguages ?? new List<string>();
        if (langs.Count == 0)
        {
            throw new XunitException($"Expected detected languages {string.Join(", ", expectedList)} but field is empty");
        }

        var missing = expectedList.Where(lang => !langs.Any(candidate => string.Equals(candidate, lang, StringComparison.OrdinalIgnoreCase))).ToArray();
        if (missing.Length > 0)
        {
            throw new XunitException($"Expected languages {string.Join(", ", expectedList)}, missing {string.Join(", ", missing)}");
        }

        if (minConfidence.HasValue)
        {
            var metadataNode = MetadataToJson(result.Metadata);
            var confidence = LookupMetadata(metadataNode, "confidence");
            if (confidence is JsonValue value && value.TryGetValue<double>(out var dbl) && dbl < minConfidence.Value)
            {
                throw new XunitException($"Expected confidence >= {minConfidence.Value}, got {dbl}");
            }
        }
    }

    public static JsonNode MetadataToJson(Metadata metadata)
    {
        return Serialization.BuildMetadataNode(metadata);
    }

    public static JsonNode? LookupMetadata(JsonNode node, string path)
    {
        var direct = LookupMetadataPath(node, path);
        if (direct is not null)
        {
            return direct;
        }
        if (node is JsonObject obj && obj.TryGetPropertyValue("format", out var format) && format is not null)
        {
            return LookupMetadataPath(format, path);
        }
        return null;
    }

    private static JsonNode? LookupMetadataPath(JsonNode node, string path)
    {
        var current = node;
        foreach (var segment in path.Split('.', StringSplitOptions.RemoveEmptyEntries))
        {
            if (current is not JsonObject obj || !obj.TryGetPropertyValue(segment, out var next))
            {
                return null;
            }
            current = next!;
        }
        return current;
    }

    public static void AssertMetadata(JsonNode metadata, string path, string expectationJson)
    {
        var value = LookupMetadata(metadata, path);
        if (value is null)
        {
            throw new XunitException($"Metadata path {path} missing");
        }

        var spec = JsonNode.Parse(expectationJson)?.AsObject();
        if (spec is null)
        {
            throw new XunitException($"Invalid expectation for {path}: {expectationJson}");
        }

        if (spec.TryGetPropertyValue("eq", out var eq) && eq is not null)
        {
            if (!JsonEquals(value, eq))
            {
                throw new XunitException($"Expected metadata {path} == {eq}, got {value}");
            }
        }
        if (spec.TryGetPropertyValue("gte", out var gte) && gte is not null)
        {
            if (!CompareFloat(value, gte, true))
            {
                throw new XunitException($"Expected metadata {path} >= {gte}, got {value}");
            }
        }
        if (spec.TryGetPropertyValue("lte", out var lte) && lte is not null)
        {
            if (!CompareFloat(value, lte, false))
            {
                throw new XunitException($"Expected metadata {path} <= {lte}, got {value}");
            }
        }
        if (spec.TryGetPropertyValue("contains", out var contains) && contains is not null)
        {
            if (!ValueContains(value, contains))
            {
                throw new XunitException($"Expected metadata {path} to contain {contains}, got {value}");
            }
        }
    }

    private static bool JsonEquals(JsonNode a, JsonNode b)
    {
        if (a is JsonValue av && b is JsonValue bv)
        {
            if (av.TryGetValue<string>(out var aStr) && bv.TryGetValue<string>(out var bStr))
            {
                return aStr == bStr;
            }
            if (av.TryGetValue<double>(out var aNum) && bv.TryGetValue<double>(out var bNum))
            {
                return Math.Abs(aNum - bNum) < 1e-9;
            }
            if (av.TryGetValue<bool>(out var aBool) && bv.TryGetValue<bool>(out var bBool))
            {
                return aBool == bBool;
            }
        }

        if (a is JsonArray aa && b is JsonArray ba && aa.Count == ba.Count)
        {
            for (var i = 0; i < aa.Count; i++)
            {
                if (!JsonEquals(aa[i]!, ba[i]!))
                {
                    return false;
                }
            }
            return true;
        }

        return a.ToJsonString() == b.ToJsonString();
    }

    private static bool CompareFloat(JsonNode actual, JsonNode expected, bool gte)
    {
        try
        {
            double? actualVal = null;
            double? expectedVal = null;

            if (actual is JsonValue av)
            {
                if (av.TryGetValue<double>(out var d))
                    actualVal = d;
                else if (av.TryGetValue<int>(out var i))
                    actualVal = i;
            }

            if (expected is JsonValue ev)
            {
                if (ev.TryGetValue<double>(out var d))
                    expectedVal = d;
                else if (ev.TryGetValue<int>(out var i))
                    expectedVal = i;
            }

            if (actualVal is null || expectedVal is null)
                return false;

            return gte ? actualVal >= expectedVal : actualVal <= expectedVal;
        }
        catch
        {
            return false;
        }
    }

    private static bool ValueContains(JsonNode value, JsonNode contains)
    {
        if (value is JsonValue valueScalar && contains is JsonValue containsScalar)
        {
            if (valueScalar.TryGetValue<string>(out var valueStr) &&
                containsScalar.TryGetValue<string>(out var containsStr))
            {
                return valueStr.Contains(containsStr, StringComparison.OrdinalIgnoreCase);
            }
        }

        if (value is JsonArray valueArray &&
            contains is JsonValue containsValue &&
            containsValue.TryGetValue<string>(out var needle))
        {
            foreach (var arrayValue in valueArray)
            {
                if (arrayValue is JsonValue arrayScalar &&
                    arrayScalar.TryGetValue<string>(out var arrayStr) &&
                    arrayStr.Contains(needle, StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }
            }
            return false;
        }

        if (value is JsonArray valueArrayAll && contains is JsonArray containsArray)
        {
            foreach (var item in containsArray)
            {
                bool found = false;
                foreach (var arrayValue in valueArrayAll)
                {
                    if (JsonEquals(arrayValue!, item!))
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                    return false;
            }
            return true;
        }

        return false;
    }

    public static void AssertChunks(
        ExtractionResult result,
        int? minCount,
        int? maxCount,
        bool? eachHasContent,
        bool? eachHasEmbedding)
    {
        var chunks = result.Chunks;
        if (chunks is null)
        {
            throw new XunitException("Expected chunks but got null");
        }
        var count = chunks.Count;
        if (minCount.HasValue && count < minCount.Value)
        {
            throw new XunitException($"Expected at least {minCount.Value} chunks, found {count}");
        }
        if (maxCount.HasValue && count > maxCount.Value)
        {
            throw new XunitException($"Expected at most {maxCount.Value} chunks, found {count}");
        }
        if (eachHasContent == true)
        {
            for (var i = 0; i < chunks.Count; i++)
            {
                if (string.IsNullOrEmpty(chunks[i].Content))
                {
                    throw new XunitException($"Chunk {i} has no content");
                }
            }
        }
        if (eachHasEmbedding == true)
        {
            for (var i = 0; i < chunks.Count; i++)
            {
                if (chunks[i].Embedding is null || chunks[i].Embedding!.Length == 0)
                {
                    throw new XunitException($"Chunk {i} has no embedding");
                }
            }
        }
    }

    public static void AssertImages(
        ExtractionResult result,
        int? minCount,
        int? maxCount,
        IEnumerable<string>? formatsInclude)
    {
        var images = result.Images;
        if (images is null)
        {
            throw new XunitException("Expected images but got null");
        }
        var count = images.Count;
        if (minCount.HasValue && count < minCount.Value)
        {
            throw new XunitException($"Expected at least {minCount.Value} images, found {count}");
        }
        if (maxCount.HasValue && count > maxCount.Value)
        {
            throw new XunitException($"Expected at most {maxCount.Value} images, found {count}");
        }
        if (formatsInclude is not null)
        {
            var foundFormats = images.Select(img => img.Format).ToHashSet();
            foreach (var fmt in formatsInclude)
            {
                if (!foundFormats.Contains(fmt))
                {
                    throw new XunitException($"Expected image format '{fmt}' not found in [{string.Join(", ", foundFormats)}]");
                }
            }
        }
    }

    public static void AssertPages(
        ExtractionResult result,
        int? minCount,
        int? exactCount)
    {
        var pages = result.Pages;
        if (pages is null)
        {
            throw new XunitException("Expected pages but got null");
        }
        var count = pages.Count;
        if (exactCount.HasValue && count != exactCount.Value)
        {
            throw new XunitException($"Expected exactly {exactCount.Value} pages, found {count}");
        }
        if (minCount.HasValue && count < minCount.Value)
        {
            throw new XunitException($"Expected at least {minCount.Value} pages, found {count}");
        }
        foreach (var page in pages)
        {
            // IsBlank should be accessible as bool?
            var _ = page.IsBlank;
        }
    }

    public static void AssertElements(
        ExtractionResult result,
        int? minCount,
        IEnumerable<string>? typesInclude)
    {
        var elements = result.Elements;
        if (elements is null)
        {
            throw new XunitException("Expected elements but got null");
        }
        var count = elements.Count;
        if (minCount.HasValue && count < minCount.Value)
        {
            throw new XunitException($"Expected at least {minCount.Value} elements, found {count}");
        }
        if (typesInclude is not null)
        {
            var foundTypes = elements.Select(el => el.ElementType.ToString()).ToHashSet();
            foreach (var elType in typesInclude)
            {
                if (!foundTypes.Contains(elType))
                {
                    throw new XunitException($"Expected element type '{elType}' not found in [{string.Join(", ", foundTypes)}]");
                }
            }
        }
    }

    public static void AssertOcrElements(
        ExtractionResult result,
        bool? hasElements,
        bool? hasGeometry,
        bool? hasConfidence,
        int? minCount)
    {
        var ocrElements = result.OcrElements;
        if (hasElements == true)
        {
            if (ocrElements is null || ocrElements.Count == 0)
            {
                throw new XunitException("Expected OCR elements but none found");
            }
        }
        if (ocrElements is not null)
        {
            if (hasGeometry == true)
            {
                for (var i = 0; i < ocrElements.Count; i++)
                {
                    if (ocrElements[i].Geometry is null)
                    {
                        throw new XunitException($"OCR element {i} expected to have geometry");
                    }
                }
            }
            if (hasConfidence == true)
            {
                for (var i = 0; i < ocrElements.Count; i++)
                {
                    if (ocrElements[i].Confidence is null)
                    {
                        throw new XunitException($"OCR element {i} expected to have confidence score");
                    }
                }
            }
            if (minCount.HasValue && ocrElements.Count < minCount.Value)
            {
                throw new XunitException($"Expected at least {minCount.Value} OCR elements, found {ocrElements.Count}");
            }
        }
    }

    public static void AssertDocument(
        ExtractionResult result,
        bool hasDocument,
        int? minNodeCount,
        IEnumerable<string>? nodeTypesInclude,
        bool? hasGroups)
    {
        var document = result.Document;
        if (hasDocument)
        {
            if (document is null)
            {
                throw new XunitException("Expected document but got null");
            }
            var nodes = document.Nodes;
            if (nodes is null)
            {
                throw new XunitException("Expected document nodes but got null");
            }
            if (minNodeCount.HasValue && nodes.Count < minNodeCount.Value)
            {
                throw new XunitException($"Expected at least {minNodeCount.Value} nodes, found {nodes.Count}");
            }
            if (nodeTypesInclude is not null)
            {
                var foundTypes = nodes.Select(n => n.Content?.NodeType ?? "").ToHashSet();
                foreach (var expected in nodeTypesInclude)
                {
                    if (!foundTypes.Any(t => string.Equals(t, expected, StringComparison.OrdinalIgnoreCase)))
                    {
                        throw new XunitException($"Expected node type '{expected}' not found in [{string.Join(", ", foundTypes)}]");
                    }
                }
            }
            if (hasGroups.HasValue)
            {
                var hasGroupNodes = nodes.Any(n => string.Equals(n.Content?.NodeType, "group", StringComparison.OrdinalIgnoreCase));
                if (hasGroupNodes != hasGroups.Value)
                {
                    throw new XunitException($"Expected hasGroups={hasGroups.Value} but got {hasGroupNodes}");
                }
            }
        }
        else
        {
            if (document is not null)
            {
                throw new XunitException($"Expected document to be null but got a document");
            }
        }
    }

    public static void AssertKeywords(
        ExtractionResult result,
        bool? hasKeywords,
        int? minCount,
        int? maxCount)
    {
        var keywords = result.ExtractedKeywords;
        if (hasKeywords == true)
        {
            if (keywords is null || keywords.Count == 0)
            {
                throw new XunitException("Expected keywords but got null or empty");
            }
        }
        if (hasKeywords == false)
        {
            if (keywords is not null && keywords.Count > 0)
            {
                throw new XunitException("Expected keywords to be null or empty");
            }
            return;
        }
        if (keywords is not null)
        {
            var count = keywords.Count;
            if (minCount.HasValue && count < minCount.Value)
            {
                throw new XunitException($"Expected at least {minCount.Value} keywords, found {count}");
            }
            if (maxCount.HasValue && count > maxCount.Value)
            {
                throw new XunitException($"Expected at most {maxCount.Value} keywords, found {count}");
            }
        }
    }

    public static void AssertContentNotEmpty(ExtractionResult result)
    {
        if (string.IsNullOrEmpty(result.Content))
        {
            throw new XunitException("Expected content to be non-empty, but it is empty");
        }
    }

    public static void AssertTableBoundingBoxes(ExtractionResult result)
    {
        var tables = result.Tables;
        if (tables is not null)
        {
            for (var i = 0; i < tables.Count; i++)
            {
                if (tables[i].BoundingBox is null)
                {
                    throw new XunitException($"Table {i} expected to have bounding box");
                }
            }
        }
    }

    public static void AssertTableContentContainsAny(ExtractionResult result, IEnumerable<string> snippets)
    {
        var list = snippets.ToArray();
        if (list.Length == 0) return;
        var tables = result.Tables;
        var allContent = string.Join(" ", (tables ?? new List<Table>()).Select(t => (t.Markdown ?? "").ToLowerInvariant()));
        foreach (var snippet in list)
        {
            if (allContent.Contains(snippet.ToLowerInvariant()))
            {
                return;
            }
        }
        throw new XunitException($"Expected table content to contain any of [{string.Join(", ", list)}]");
    }

    public static void AssertImageBoundingBoxes(ExtractionResult result)
    {
        var images = result.Images;
        if (images is not null)
        {
            for (var i = 0; i < images.Count; i++)
            {
                if (images[i].BoundingBox is null)
                {
                    throw new XunitException($"Image {i} expected to have bounding box");
                }
            }
        }
    }

    public static void AssertQualityScore(ExtractionResult result, bool? hasScore, double? minScore, double? maxScore)
    {
        if (hasScore == true)
        {
            if (result.QualityScore is null)
            {
                throw new XunitException("Expected quality score to be present");
            }
        }
        if (minScore.HasValue && result.QualityScore.HasValue)
        {
            if (result.QualityScore.Value < minScore.Value)
            {
                throw new XunitException($"Expected quality score >= {minScore.Value}, got {result.QualityScore.Value}");
            }
        }
        if (maxScore.HasValue && result.QualityScore.HasValue)
        {
            if (result.QualityScore.Value > maxScore.Value)
            {
                throw new XunitException($"Expected quality score <= {maxScore.Value}, got {result.QualityScore.Value}");
            }
        }
    }

    public static void AssertProcessingWarnings(ExtractionResult result, int? maxCount, bool? isEmpty)
    {
        var warnings = result.ProcessingWarnings;
        var count = warnings?.Count ?? 0;
        if (isEmpty == true && count != 0)
        {
            throw new XunitException($"Expected processing warnings to be empty, got {count}");
        }
        if (maxCount.HasValue && count > maxCount.Value)
        {
            throw new XunitException($"Expected at most {maxCount.Value} processing warnings, got {count}");
        }
    }

    public static void AssertDjotContent(ExtractionResult result, bool? hasContent, int? minBlocks)
    {
        var djotContent = result.DjotContent;
        if (hasContent == true)
        {
            if (djotContent is null || string.IsNullOrEmpty(djotContent.PlainText))
            {
                throw new XunitException("Expected djot content to be present");
            }
        }
        if (minBlocks.HasValue && djotContent is not null)
        {
            var blockCount = djotContent.Blocks?.Count ?? 0;
            if (blockCount < minBlocks.Value)
            {
                throw new XunitException($"Expected at least {minBlocks.Value} djot blocks, got {blockCount}");
            }
        }
    }
}
"#;

pub fn generate(fixtures: &[Fixture], output_root: &Utf8Path) -> Result<()> {
    let csharp_root = output_root.join("csharp");

    fs::create_dir_all(&csharp_root).context("Failed to create csharp output directory")?;

    clean_tests(&csharp_root)?;
    write_helpers(&csharp_root)?;

    let doc_fixtures: Vec<_> = fixtures.iter().filter(|f| f.is_document_extraction()).collect();

    let mut grouped = doc_fixtures
        .into_iter()
        .into_group_map_by(|fixture| fixture.category().to_string())
        .into_iter()
        .collect::<Vec<_>>();
    grouped.sort_by(|a, b| a.0.cmp(&b.0));

    for (category, mut fixtures) in grouped {
        fixtures.sort_by(|a, b| a.id.cmp(&b.id));
        let filename = format!("{}Tests.cs", sanitize_typename(&category));
        let content = render_category(&category, &fixtures)?;
        fs::write(csharp_root.join(&filename), content)
            .with_context(|| format!("Failed to write C# test file {filename}"))?;
    }

    let plugin_fixtures: Vec<_> = fixtures.iter().filter(|f| f.is_plugin_api()).collect();
    if !plugin_fixtures.is_empty() {
        generate_plugin_api_tests(&plugin_fixtures, &csharp_root)?;
    }

    Ok(())
}

fn clean_tests(dir: &Utf8Path) -> Result<()> {
    if !dir.exists() {
        return Ok(());
    }

    for entry in fs::read_dir(dir.as_std_path())? {
        let entry = entry?;
        if entry.path().extension().is_some_and(|ext| ext == "cs") {
            let name = entry.file_name().to_string_lossy().to_string();
            if name.ends_with("Tests.cs") || name == "Helpers.cs" {
                fs::remove_file(entry.path())?;
            }
        }
    }

    Ok(())
}

fn write_helpers(root: &Utf8Path) -> Result<()> {
    let helpers_path = root.join("Helpers.cs");
    fs::write(helpers_path.as_std_path(), CSHARP_HELPERS_TEMPLATE).context("Failed to write Helpers.cs")?;
    Ok(())
}

fn render_category(category: &str, fixtures: &[&Fixture]) -> Result<String> {
    let mut buffer = String::new();
    writeln!(buffer, "// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.")?;
    writeln!(buffer, "using System;")?;
    writeln!(buffer, "using System.Collections.Generic;")?;
    writeln!(buffer, "using System.IO;")?;
    writeln!(buffer, "using System.Threading.Tasks;")?;
    writeln!(buffer, "using Kreuzberg;")?;
    writeln!(buffer, "using Xunit;")?;
    writeln!(buffer, "using Kreuzberg.E2E;\n")?;

    let namespace = format!("Kreuzberg.E2E.{}", sanitize_typename(category));
    writeln!(buffer, "namespace {namespace} {{")?;
    writeln!(buffer, "    public class {}Tests", sanitize_typename(category))?;
    writeln!(buffer, "    {{")?;

    for fixture in fixtures {
        render_test(&mut buffer, fixture)?;
    }

    writeln!(buffer, "    }}")?;
    writeln!(buffer, "}}")?;

    Ok(buffer)
}

fn render_config_expression(config: &Map<String, Value>) -> Result<String> {
    if config.is_empty() {
        Ok("null".to_string())
    } else {
        let json = serde_json::to_string(&Value::Object(config.clone()))?;
        let escaped = json
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n")
            .replace('\r', "\\r")
            .replace('\t', "\\t");
        Ok(format!("\"{}\"", escaped))
    }
}

fn render_test(buffer: &mut String, fixture: &Fixture) -> Result<()> {
    let test_name = sanitize_method_name(&fixture.id);
    let extraction = fixture.extraction();
    let is_async = matches!(
        extraction.method,
        ExtractionMethod::Async | ExtractionMethod::BatchAsync
    );

    writeln!(buffer, "        [SkippableFact]")?;
    if is_async {
        writeln!(buffer, "        public async Task {}()", test_name)?;
    } else {
        writeln!(buffer, "        public void {}()", test_name)?;
    }
    writeln!(buffer, "        {{")?;

    let doc = fixture.document();
    let config_json = render_config_expression(&extraction.config)?;
    // Skip if fixture requires features that may not be available
    let skip_directive = fixture.skip();
    let all_features: Vec<&str> = skip_directive
        .requires_feature
        .iter()
        .chain(doc.requires_external_tool.iter().filter(|t| *t == "paddle-ocr"))
        .map(|s| s.as_str())
        .collect();
    for feature in &all_features {
        writeln!(
            buffer,
            "            TestHelpers.SkipIfFeatureUnavailable(\"{}\");",
            escape_csharp_string(feature)
        )?;
    }
    writeln!(
        buffer,
        "            TestHelpers.SkipIfLegacyOfficeDisabled(\"{}\");",
        escape_csharp_string(&doc.path)
    )?;
    writeln!(
        buffer,
        "            TestHelpers.SkipIfOfficeTestOnWindows(\"{}\");",
        escape_csharp_string(&doc.path)
    )?;
    writeln!(
        buffer,
        "            var documentPath = TestHelpers.EnsureDocument(\"{}\", true);",
        escape_csharp_string(&doc.path)
    )?;
    writeln!(
        buffer,
        "            var config = TestHelpers.BuildConfig({});",
        config_json
    )?;
    writeln!(buffer)?;

    // Generate extraction call based on method and input type
    match (extraction.method, extraction.input_type) {
        (ExtractionMethod::Sync, InputType::File) => {
            writeln!(
                buffer,
                "            var result = KreuzbergClient.ExtractFileSync(documentPath, config);"
            )?;
        }
        (ExtractionMethod::Sync, InputType::Bytes) => {
            writeln!(buffer, "            var fileBytes = File.ReadAllBytes(documentPath);")?;
            writeln!(
                buffer,
                "            var mimeType = KreuzbergClient.DetectMimeType(fileBytes);"
            )?;
            writeln!(
                buffer,
                "            var result = KreuzbergClient.ExtractBytesSync(fileBytes, mimeType, config);"
            )?;
        }
        (ExtractionMethod::Async, InputType::File) => {
            writeln!(
                buffer,
                "            var result = await KreuzbergClient.ExtractFileAsync(documentPath, config);"
            )?;
        }
        (ExtractionMethod::Async, InputType::Bytes) => {
            writeln!(
                buffer,
                "            var fileBytes = await File.ReadAllBytesAsync(documentPath);"
            )?;
            writeln!(
                buffer,
                "            var mimeType = KreuzbergClient.DetectMimeType(fileBytes);"
            )?;
            writeln!(
                buffer,
                "            var result = await KreuzbergClient.ExtractBytesAsync(fileBytes, mimeType, config);"
            )?;
        }
        (ExtractionMethod::BatchSync, InputType::File) => {
            writeln!(
                buffer,
                "            var results = KreuzbergClient.BatchExtractFilesSync(new[] {{ documentPath }}, config);"
            )?;
            writeln!(buffer, "            var result = results[0];")?;
        }
        (ExtractionMethod::BatchSync, InputType::Bytes) => {
            writeln!(buffer, "            var fileBytes = File.ReadAllBytes(documentPath);")?;
            writeln!(
                buffer,
                "            var mimeType = KreuzbergClient.DetectMimeType(fileBytes);"
            )?;
            writeln!(
                buffer,
                "            var results = KreuzbergClient.BatchExtractBytesSync(new[] {{ new BytesWithMime(fileBytes, mimeType) }}, config);"
            )?;
            writeln!(buffer, "            var result = results[0];")?;
        }
        (ExtractionMethod::BatchAsync, InputType::File) => {
            writeln!(
                buffer,
                "            var results = await KreuzbergClient.BatchExtractFilesAsync(new[] {{ documentPath }}, config);"
            )?;
            writeln!(buffer, "            var result = results[0];")?;
        }
        (ExtractionMethod::BatchAsync, InputType::Bytes) => {
            writeln!(
                buffer,
                "            var fileBytes = await File.ReadAllBytesAsync(documentPath);"
            )?;
            writeln!(
                buffer,
                "            var mimeType = KreuzbergClient.DetectMimeType(fileBytes);"
            )?;
            writeln!(
                buffer,
                "            var results = await KreuzbergClient.BatchExtractBytesAsync(new[] {{ new BytesWithMime(fileBytes, mimeType) }}, config);"
            )?;
            writeln!(buffer, "            var result = results[0];")?;
        }
    }

    let assertions = fixture.assertions();
    render_assertions(buffer, &assertions)?;

    writeln!(buffer, "        }}\n")?;

    Ok(())
}

fn render_assertions(buffer: &mut String, assertions: &Assertions) -> Result<()> {
    if !assertions.expected_mime.is_empty() {
        let mimes = render_string_array(&assertions.expected_mime);
        writeln!(
            buffer,
            "            TestHelpers.AssertExpectedMime(result, new[] {{ {} }});",
            mimes
        )?;
    }

    if let Some(min) = assertions.min_content_length {
        writeln!(
            buffer,
            "            TestHelpers.AssertMinContentLength(result, {});",
            min
        )?;
    }

    if let Some(max) = assertions.max_content_length {
        writeln!(
            buffer,
            "            TestHelpers.AssertMaxContentLength(result, {});",
            max
        )?;
    }

    if !assertions.content_contains_any.is_empty() {
        let snippets = render_string_array(&assertions.content_contains_any);
        writeln!(
            buffer,
            "            TestHelpers.AssertContentContainsAny(result, new[] {{ {} }});",
            snippets
        )?;
    }

    if !assertions.content_contains_all.is_empty() {
        let snippets = render_string_array(&assertions.content_contains_all);
        writeln!(
            buffer,
            "            TestHelpers.AssertContentContainsAll(result, new[] {{ {} }});",
            snippets
        )?;
    }

    if let Some(tables) = assertions.tables.as_ref() {
        let min_str = tables
            .min
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        let max_str = tables
            .max
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertTableCount(result, {}, {});",
            min_str, max_str
        )?;
        if tables.has_bounding_boxes == Some(true) {
            writeln!(buffer, "            TestHelpers.AssertTableBoundingBoxes(result);")?;
        }
        if let Some(snippets) = tables.content_contains_any.as_ref()
            && !snippets.is_empty()
        {
            writeln!(
                buffer,
                "            TestHelpers.AssertTableContentContainsAny(result, new[] {{ {} }});",
                render_string_array(snippets)
            )?;
        }
    }

    if let Some(languages) = assertions.detected_languages.as_ref() {
        let expected = render_string_array(&languages.expects);
        let min_conf = languages
            .min_confidence
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertDetectedLanguages(result, new[] {{ {} }}, {});",
            expected, min_conf
        )?;
    }

    if !assertions.metadata.is_empty() {
        writeln!(
            buffer,
            "            var metadataNode = TestHelpers.MetadataToJson(result.Metadata);"
        )?;
        for (path, expectation) in &assertions.metadata {
            let expectation_json = render_csharp_metadata_expectation(expectation);
            writeln!(
                buffer,
                "            TestHelpers.AssertMetadata(metadataNode, \"{}\", @\"{}\");",
                escape_csharp_string(path),
                escape_csharp_verbatim_string(&expectation_json)
            )?;
        }
    }

    if let Some(chunks) = assertions.chunks.as_ref() {
        let min_count = chunks
            .min_count
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        let max_count = chunks
            .max_count
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        let each_has_content = chunks
            .each_has_content
            .map(|v| if v { "true" } else { "false" }.to_string())
            .unwrap_or_else(|| "null".to_string());
        let each_has_embedding = chunks
            .each_has_embedding
            .map(|v| if v { "true" } else { "false" }.to_string())
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertChunks(result, {}, {}, {}, {});",
            min_count, max_count, each_has_content, each_has_embedding
        )?;
    }

    if let Some(images) = assertions.images.as_ref() {
        let min_count = images
            .min_count
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        let max_count = images
            .max_count
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        let formats_include = images
            .formats_include
            .as_ref()
            .map(|formats| format!("new[] {{ {} }}", render_string_array(formats)))
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertImages(result, {}, {}, {});",
            min_count, max_count, formats_include
        )?;
        if images.has_bounding_boxes == Some(true) {
            writeln!(buffer, "            TestHelpers.AssertImageBoundingBoxes(result);")?;
        }
    }

    if let Some(pages) = assertions.pages.as_ref() {
        let min_count = pages
            .min_count
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        let exact_count = pages
            .exact_count
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertPages(result, {}, {});",
            min_count, exact_count
        )?;
    }

    if let Some(elements) = assertions.elements.as_ref() {
        let min_count = elements
            .min_count
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        let types_include = elements
            .types_include
            .as_ref()
            .map(|types| format!("new[] {{ {} }}", render_string_array(types)))
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertElements(result, {}, {});",
            min_count, types_include
        )?;
    }

    if let Some(ocr) = assertions.ocr_elements.as_ref() {
        let has_elements = ocr
            .has_elements
            .map(|v| if v { "true" } else { "false" }.to_string())
            .unwrap_or_else(|| "null".to_string());
        let has_geometry = ocr
            .elements_have_geometry
            .map(|v| if v { "true" } else { "false" }.to_string())
            .unwrap_or_else(|| "null".to_string());
        let has_confidence = ocr
            .elements_have_confidence
            .map(|v| if v { "true" } else { "false" }.to_string())
            .unwrap_or_else(|| "null".to_string());
        let min_count = ocr
            .min_count
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertOcrElements(result, {}, {}, {}, {});",
            has_elements, has_geometry, has_confidence, min_count
        )?;
    }

    if let Some(document) = assertions.document.as_ref() {
        let has_document = if document.has_document { "true" } else { "false" };
        let min_node_count = document
            .min_node_count
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        let node_types = if !document.node_types_include.is_empty() {
            format!("new[] {{ {} }}", render_string_array(&document.node_types_include))
        } else {
            "null".to_string()
        };
        let has_groups = document
            .has_groups
            .map(|v| if v { "true" } else { "false" }.to_string())
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertDocument(result, {}, {}, {}, {});",
            has_document, min_node_count, node_types, has_groups
        )?;
    }

    if let Some(keywords) = assertions.keywords.as_ref() {
        let has_keywords = keywords
            .has_keywords
            .map(|v| if v { "true" } else { "false" }.to_string())
            .unwrap_or_else(|| "null".to_string());
        let min_count = keywords
            .min_count
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        let max_count = keywords
            .max_count
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertKeywords(result, {}, {}, {});",
            has_keywords, min_count, max_count
        )?;
    }

    if assertions.content_not_empty == Some(true) {
        writeln!(buffer, "            TestHelpers.AssertContentNotEmpty(result);")?;
    }
    if let Some(qs) = assertions.quality_score.as_ref() {
        let has_score = qs
            .has_score
            .map(|v| if v { "true" } else { "false" }.to_string())
            .unwrap_or_else(|| "null".to_string());
        let min_score = qs
            .min_score
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        let max_score = qs
            .max_score
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertQualityScore(result, {}, {}, {});",
            has_score, min_score, max_score
        )?;
    }
    if let Some(pw) = assertions.processing_warnings.as_ref() {
        let max_count = pw
            .max_count
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        let is_empty = pw
            .is_empty
            .map(|v| if v { "true" } else { "false" }.to_string())
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertProcessingWarnings(result, {}, {});",
            max_count, is_empty
        )?;
    }
    if let Some(dc) = assertions.djot_content.as_ref() {
        let has_content = dc
            .has_content
            .map(|v| if v { "true" } else { "false" }.to_string())
            .unwrap_or_else(|| "null".to_string());
        let min_blocks = dc
            .min_blocks
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertDjotContent(result, {}, {});",
            has_content, min_blocks
        )?;
    }

    Ok(())
}

fn render_string_array(values: &[String]) -> String {
    values
        .iter()
        .map(|v| format!("\"{}\"", escape_csharp_string(v)))
        .collect::<Vec<_>>()
        .join(", ")
}

fn render_csharp_metadata_expectation(value: &Value) -> String {
    match value {
        Value::Object(map) => {
            if map.is_empty() {
                return "{}".to_string();
            }
            let parts = map
                .iter()
                .map(|(key, val)| format!("\"{}\": {}", escape_csharp_string(key), render_csharp_value(val)))
                .collect::<Vec<_>>()
                .join(", ");
            format!("{{{}}}", parts)
        }
        _ => {
            let value_expr = render_csharp_value(value);
            format!("{{\"eq\": {}}}", value_expr)
        }
    }
}

fn render_csharp_value(value: &Value) -> String {
    match value {
        Value::Null => "null".to_string(),
        Value::Bool(b) => if *b { "true" } else { "false" }.to_string(),
        Value::Number(n) => n.to_string(),
        Value::String(s) => format!("\"{}\"", escape_csharp_string(s)),
        Value::Array(items) => {
            let parts = items.iter().map(render_csharp_value).collect::<Vec<_>>().join(", ");
            format!("[{}]", parts)
        }
        Value::Object(map) => {
            let parts = map
                .iter()
                .map(|(key, val)| format!("\"{}\": {}", escape_csharp_string(key), render_csharp_value(val)))
                .collect::<Vec<_>>()
                .join(", ");
            format!("{{{}}}", parts)
        }
    }
}

fn sanitize_typename(input: &str) -> String {
    input
        .chars()
        .map(|c| match c {
            'a'..='z' | 'A'..='Z' | '0'..='9' => c,
            _ => '_',
        })
        .collect::<String>()
        .split('_')
        .filter(|s| !s.is_empty())
        .map(|s| {
            let mut chars = s.chars();
            match chars.next() {
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                None => String::new(),
            }
        })
        .collect::<Vec<_>>()
        .join("")
}

fn sanitize_method_name(input: &str) -> String {
    input
        .chars()
        .map(|c| match c {
            'a'..='z' | 'A'..='Z' | '0'..='9' => c,
            _ => '_',
        })
        .collect::<String>()
        .split('_')
        .filter(|s| !s.is_empty())
        .map(|s| {
            let mut chars = s.chars();
            match chars.next() {
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                None => String::new(),
            }
        })
        .collect::<Vec<_>>()
        .join("")
}

fn escape_csharp_string(value: &str) -> String {
    value
        .replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

fn escape_csharp_verbatim_string(value: &str) -> String {
    value.replace('"', "\"\"")
}

// ---------------------------------------------------------------------------
// Plugin API test generation
// ---------------------------------------------------------------------------

fn snake_to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                None => String::new(),
            }
        })
        .collect::<Vec<_>>()
        .join("")
}

fn category_to_title(category: &str) -> String {
    category
        .split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
                None => String::new(),
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}

fn generate_plugin_api_tests(fixtures: &[&Fixture], output_dir: &Utf8Path) -> Result<()> {
    let mut content = String::new();

    writeln!(content, "// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.")?;
    writeln!(content, "using System;")?;
    writeln!(content, "using System.Collections.Generic;")?;
    writeln!(content, "using System.IO;")?;
    writeln!(content, "using System.Linq;")?;
    writeln!(content, "using Kreuzberg;")?;
    writeln!(content, "using Xunit;")?;
    writeln!(content)?;
    writeln!(content, "namespace Kreuzberg.E2E.PluginApis;")?;
    writeln!(content)?;
    writeln!(content, "/// <summary>")?;
    writeln!(content, "/// E2E tests for plugin/config/utility APIs.")?;
    writeln!(content, "///")?;
    writeln!(content, "/// Generated from plugin API fixtures.")?;
    writeln!(
        content,
        "/// To regenerate: cargo run -p kreuzberg-e2e-generator -- generate --lang csharp"
    )?;
    writeln!(content, "/// </summary>")?;
    writeln!(content, "public class PluginAPIsTests")?;
    writeln!(content, "{{")?;

    let mut grouped: std::collections::BTreeMap<&str, Vec<&Fixture>> = std::collections::BTreeMap::new();
    for fixture in fixtures {
        let category = fixture
            .api_category
            .as_ref()
            .with_context(|| format!("Fixture '{}' missing api_category", fixture.id))?
            .as_str();
        grouped.entry(category).or_default().push(fixture);
    }

    for (category, fixtures) in &grouped {
        writeln!(content, "    // {} Tests", category_to_title(category))?;
        writeln!(content)?;

        for fixture in fixtures {
            generate_csharp_test_method(fixture, &mut content)?;
            writeln!(content)?;
        }
    }

    writeln!(content, "}}")?;

    let test_file = output_dir.join("PluginAPIsTests.cs");
    fs::write(&test_file, content).with_context(|| format!("Failed to write {test_file}"))?;

    Ok(())
}

fn generate_csharp_test_method(fixture: &Fixture, buf: &mut String) -> Result<()> {
    let test_spec = fixture
        .test_spec
        .as_ref()
        .with_context(|| format!("Fixture '{}' missing test_spec", fixture.id))?;

    let test_name = sanitize_typename(&fixture.id);

    // config_discover requires changing working directory which is process-global  skip
    if test_spec.pattern == "config_discover" {
        writeln!(
            buf,
            "    // SKIPPED: config_discover - Environment.CurrentDirectory doesn't reliably affect FFI"
        )?;
        return Ok(());
    }

    writeln!(buf, "    [Fact]")?;

    match test_spec.pattern.as_str() {
        "config_from_file" | "mime_from_path" => {
            writeln!(buf, "    public void {}()", test_name)?;
        }
        _ => {
            writeln!(buf, "    public void {}()", test_name)?;
        }
    }

    writeln!(buf, "    {{")?;

    match test_spec.pattern.as_str() {
        "simple_list" => generate_simple_list_test_cs(test_spec, buf)?,
        "clear_registry" => generate_clear_registry_test_cs(test_spec, buf)?,
        "graceful_unregister" => generate_graceful_unregister_test_cs(test_spec, buf)?,
        "config_from_file" => generate_config_from_file_test_cs(test_spec, buf)?,
        "mime_from_bytes" => generate_mime_from_bytes_test_cs(test_spec, buf)?,
        "mime_from_path" => generate_mime_from_path_test_cs(test_spec, buf)?,
        "mime_extension_lookup" => generate_mime_extension_lookup_test_cs(test_spec, buf)?,
        _ => anyhow::bail!("Unknown test pattern: {}", test_spec.pattern),
    }

    writeln!(buf, "    }}")?;

    Ok(())
}

fn generate_simple_list_test_cs(test_spec: &PluginTestSpec, buf: &mut String) -> Result<()> {
    let func_name = snake_to_pascal_case(&test_spec.function_call.name);

    writeln!(buf, "        var result = KreuzbergClient.{}();", func_name)?;
    writeln!(buf, "        Assert.NotNull(result);")?;

    if let Some(item_type) = &test_spec.assertions.list_item_type
        && item_type == "string"
    {
        writeln!(buf, "        Assert.All(result, item => Assert.IsType<string>(item));")?;
    }

    if let Some(contains) = &test_spec.assertions.list_contains {
        writeln!(
            buf,
            "        Assert.Contains(\"{}\", result);",
            escape_csharp_string(contains)
        )?;
    }

    Ok(())
}

fn generate_clear_registry_test_cs(test_spec: &PluginTestSpec, buf: &mut String) -> Result<()> {
    let clear_func = snake_to_pascal_case(&test_spec.function_call.name);
    let list_func = clear_func.replace("Clear", "List");

    writeln!(buf, "        KreuzbergClient.{}();", clear_func)?;
    writeln!(buf, "        var result = KreuzbergClient.{}();", list_func)?;
    writeln!(buf, "        Assert.Empty(result);")?;

    Ok(())
}

fn generate_graceful_unregister_test_cs(test_spec: &PluginTestSpec, buf: &mut String) -> Result<()> {
    let func_name = snake_to_pascal_case(&test_spec.function_call.name);
    let arg = if let Some(Value::String(s)) = test_spec.function_call.args.first() {
        s.clone()
    } else {
        "nonexistent-item".to_string()
    };

    writeln!(
        buf,
        "        KreuzbergClient.{}(\"{}\");",
        func_name,
        escape_csharp_string(&arg)
    )?;

    Ok(())
}

fn generate_config_from_file_test_cs(test_spec: &PluginTestSpec, buf: &mut String) -> Result<()> {
    let setup = test_spec
        .setup
        .as_ref()
        .with_context(|| "Test spec missing setup for config_from_file")?;
    let file_name = setup
        .temp_file_name
        .as_ref()
        .with_context(|| "Setup missing temp_file_name")?;
    let file_content = setup
        .temp_file_content
        .as_ref()
        .with_context(|| "Setup missing temp_file_content")?;

    writeln!(
        buf,
        "        var tmpDir = Path.Combine(Path.GetTempPath(), \"kreuzberg-test-\" + Guid.NewGuid());"
    )?;
    writeln!(buf, "        Directory.CreateDirectory(tmpDir);")?;
    writeln!(buf, "        try")?;
    writeln!(buf, "        {{")?;
    writeln!(
        buf,
        "            var configPath = Path.Combine(tmpDir, \"{}\");",
        escape_csharp_string(file_name)
    )?;
    writeln!(
        buf,
        "            File.WriteAllText(configPath, \"{}\");",
        escape_csharp_string(file_content)
    )?;
    writeln!(buf)?;
    writeln!(
        buf,
        "            var config = KreuzbergClient.LoadExtractionConfigFromFile(configPath);"
    )?;

    generate_object_property_assertions_cs(&test_spec.assertions, buf, "            ")?;

    writeln!(buf, "        }}")?;
    writeln!(buf, "        finally")?;
    writeln!(buf, "        {{")?;
    writeln!(buf, "            Directory.Delete(tmpDir, true);")?;
    writeln!(buf, "        }}")?;

    Ok(())
}

fn generate_mime_from_bytes_test_cs(test_spec: &PluginTestSpec, buf: &mut String) -> Result<()> {
    let setup = test_spec
        .setup
        .as_ref()
        .with_context(|| "Test spec missing setup for mime_from_bytes")?;
    let test_data = setup.test_data.as_ref().with_context(|| "Setup missing test_data")?;
    let func_name = snake_to_pascal_case(&test_spec.function_call.name);

    writeln!(
        buf,
        "        var testBytes = System.Text.Encoding.UTF8.GetBytes(\"{}\");",
        escape_csharp_string(test_data)
    )?;
    writeln!(buf, "        var result = KreuzbergClient.{}(testBytes);", func_name)?;

    if let Some(contains) = &test_spec.assertions.string_contains {
        writeln!(
            buf,
            "        Assert.Contains(\"{}\", result.ToLower());",
            escape_csharp_string(&contains.to_lowercase())
        )?;
    }

    Ok(())
}

fn generate_mime_from_path_test_cs(test_spec: &PluginTestSpec, buf: &mut String) -> Result<()> {
    let setup = test_spec
        .setup
        .as_ref()
        .with_context(|| "Test spec missing setup for mime_from_path")?;
    let file_name = setup
        .temp_file_name
        .as_ref()
        .with_context(|| "Setup missing temp_file_name")?;
    let file_content = setup
        .temp_file_content
        .as_ref()
        .with_context(|| "Setup missing temp_file_content")?;
    let func_name = snake_to_pascal_case(&test_spec.function_call.name);

    writeln!(
        buf,
        "        var tmpDir = Path.Combine(Path.GetTempPath(), \"kreuzberg-test-\" + Guid.NewGuid());"
    )?;
    writeln!(buf, "        Directory.CreateDirectory(tmpDir);")?;
    writeln!(buf, "        try")?;
    writeln!(buf, "        {{")?;
    writeln!(
        buf,
        "            var filePath = Path.Combine(tmpDir, \"{}\");",
        escape_csharp_string(file_name)
    )?;
    writeln!(
        buf,
        "            File.WriteAllText(filePath, \"{}\");",
        escape_csharp_string(file_content)
    )?;
    writeln!(buf)?;
    writeln!(buf, "            var result = KreuzbergClient.{}(filePath);", func_name)?;

    if let Some(contains) = &test_spec.assertions.string_contains {
        writeln!(
            buf,
            "            Assert.Contains(\"{}\", result.ToLower());",
            escape_csharp_string(&contains.to_lowercase())
        )?;
    }

    writeln!(buf, "        }}")?;
    writeln!(buf, "        finally")?;
    writeln!(buf, "        {{")?;
    writeln!(buf, "            Directory.Delete(tmpDir, true);")?;
    writeln!(buf, "        }}")?;

    Ok(())
}

fn generate_mime_extension_lookup_test_cs(test_spec: &PluginTestSpec, buf: &mut String) -> Result<()> {
    let func_name = snake_to_pascal_case(&test_spec.function_call.name);
    let mime_type = if let Some(Value::String(s)) = test_spec.function_call.args.first() {
        s.clone()
    } else {
        "application/pdf".to_string()
    };

    writeln!(
        buf,
        "        var result = KreuzbergClient.{}(\"{}\");",
        func_name,
        escape_csharp_string(&mime_type)
    )?;
    writeln!(buf, "        Assert.NotNull(result);")?;

    if let Some(contains) = &test_spec.assertions.list_contains {
        writeln!(
            buf,
            "        Assert.Contains(\"{}\", result);",
            escape_csharp_string(contains)
        )?;
    }

    Ok(())
}

fn generate_object_property_assertions_cs(assertions: &PluginAssertions, buf: &mut String, indent: &str) -> Result<()> {
    for prop in &assertions.object_properties {
        let parts: Vec<&str> = prop.path.split('.').collect();
        let cs_path = parts
            .iter()
            .map(|p| snake_to_pascal_case(p))
            .collect::<Vec<_>>()
            .join(".");

        if let Some(exists) = prop.exists
            && exists
        {
            writeln!(buf, "{indent}Assert.NotNull(config.{cs_path});")?;
        }

        if let Some(value) = &prop.value {
            match value {
                Value::Number(n) => {
                    if let Some(i) = n.as_i64() {
                        writeln!(buf, "{indent}Assert.Equal({i}, config.{cs_path});")?;
                    } else if let Some(f) = n.as_f64() {
                        writeln!(buf, "{indent}Assert.Equal({f}, config.{cs_path});")?;
                    }
                }
                Value::Bool(b) => {
                    let val = if *b { "true" } else { "false" };
                    writeln!(buf, "{indent}Assert.Equal({val}, config.{cs_path});")?;
                }
                Value::String(s) => {
                    writeln!(
                        buf,
                        "{indent}Assert.Equal(\"{}\", config.{cs_path});",
                        escape_csharp_string(s)
                    )?;
                }
                _ => {}
            }
        }
    }

    Ok(())
}
